<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Evenly distributed random points | Andrey Nautilus blog</title><meta name=keywords content="procedural generation"><meta name=description content="Bridson’s Algorithm to build Poisson disk distribution of points"><meta name=author content><link rel=canonical href=https://andreynautilus.github.io/posts/2024-07-21-evenly-random-points-on-plane/><link crossorigin=anonymous href=/assets/css/stylesheet.8fe10233a706bc87f2e08b3cf97b8bd4c0a80f10675a143675d59212121037c0.css integrity="sha256-j+ECM6cGvIfy4Is8+XuL1MCoDxBnWhQ2ddWSEhIQN8A=" rel="preload stylesheet" as=style><link rel=icon href=https://andreynautilus.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://andreynautilus.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://andreynautilus.github.io/favicon-32x32.png><link rel=apple-touch-icon href=https://andreynautilus.github.io/apple-touch-icon.png><link rel=mask-icon href=https://andreynautilus.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://andreynautilus.github.io/posts/2024-07-21-evenly-random-points-on-plane/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script type=text/javascript>(function(e,t,n,s,o,i,a){e[o]=e[o]||function(){(e[o].a=e[o].a||[]).push(arguments)},e[o].l=1*new Date;for(var r=0;r<document.scripts.length;r++)if(document.scripts[r].src===s)return;i=t.createElement(n),a=t.getElementsByTagName(n)[0],i.async=1,i.src=s,a.parentNode.insertBefore(i,a)})(window,document,"script","https://mc.yandex.ru/metrika/tag.js","ym"),ym(99367858,"init",{clickmap:!0,trackLinks:!0,accurateTrackBounce:!0})</script><noscript><div><img src=https://mc.yandex.ru/watch/99367858 style=position:absolute;left:-9999px alt></div></noscript><script async src="https://www.googletagmanager.com/gtag/js?id=G-S584PB390B"></script><script>window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-S584PB390B")</script><style>.card-tags{font-size:12px}.card-tags span{background:var(--code-bg);border-radius:999px;padding:0 .7em;display:inline-block}</style><meta property="og:url" content="https://andreynautilus.github.io/posts/2024-07-21-evenly-random-points-on-plane/"><meta property="og:site_name" content="Andrey Nautilus blog"><meta property="og:title" content="Evenly distributed random points"><meta property="og:description" content="Bridson’s Algorithm to build Poisson disk distribution of points"><meta property="og:locale" content="en"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2024-07-21T20:16:16+02:00"><meta property="article:modified_time" content="2024-07-21T20:16:16+02:00"><meta property="article:tag" content="procedural generation"><meta name=twitter:card content="summary"><meta name=twitter:title content="Evenly distributed random points"><meta name=twitter:description content="Bridson’s Algorithm to build Poisson disk distribution of points"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"posts","item":"https://andreynautilus.github.io/posts/"},{"@type":"ListItem","position":2,"name":"Evenly distributed random points","item":"https://andreynautilus.github.io/posts/2024-07-21-evenly-random-points-on-plane/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Evenly distributed random points","name":"Evenly distributed random points","description":"Bridson’s Algorithm to build Poisson disk distribution of points","keywords":["procedural generation"],"articleBody":"“Random” points on a plane We need to generate random, evenly distributed points on a plane. Possible use-cases:\ngenerate trees in a forest in a game world; generate points for Voronoi diagram (with areas of similar size); The simplest approach - to use uniformly distributed points with (random(), random()) - doesn’t work, because there will be areas with high density of points and areas with no points at all. Such distribution doesn’t look natural.\nNNNN points Various types of grids with gaps can give even distribution, but the picture will not look random. There will always be a pattern, sometimes more visible, sometimes less, but still visible. This doesn’t look natural either.\nA solution to this problem is Poisson disk sampling (or Poisson disk distribution): points are placed randomly, but not too close and not too far away from each other.\nNNNN points This article compares randomly placed points with Poisson disk distribution, and shows “best candidate” and Bridson’s algorithms to build such distribution (with great examples and visualizations).\nBridson’s algorithm for Poisson disk sampling Summary of this page. Bridson’s algorithm allows us to generate random points with Poisson disk distribution.\nFormal problem description: generate tightly packed random points maintaining minimal distance between them.\nAlgorithm parameters:\narea where points should be generated; r - minimum distance between any 2 points; k - amount of attempts to generate a new point; The algorithm uses a grid with r/sqrt(2) cell size. There could be at most 1 point in any grid cell. The value of a cell is either an index of a generated point or -1.\nThe algorithm:\ninitialize the grid that covers the requested area with -1 in each cell; generate an initial point p0 and set the corresponding grid cell to 0 (the first point); initialize a list of active points with index 0; pick a random index from active points (let’s say p-i). Generate up to k random points in annulus between r and 2r form the selected point p-i; test every generated point if it’s far enough (dist \u003e=r) from already existing points (use the grid to test only nearby cells); if a generated point is far enough from all existing points, add it to the list of generated points, update the grid cell with its index and add this new point to active points; if all k points are too close to already existing points, then remove p-i from active points; repeat until list of active points is empty; Side notes:\ncomplexity is O(N); easy to implement; the cluster of points grows naturally from the starting point to all directions; easily extensible to 3D (and more dimensional) space; the number of points is not known until the generation process is complete (it’s “generate some points with specific condition” rather than “generate N points”); Links https://www.jasondavies.com/poisson-disc/ ","wordCount":"469","inLanguage":"en","datePublished":"2024-07-21T20:16:16+02:00","dateModified":"2024-07-21T20:16:16+02:00","mainEntityOfPage":{"@type":"WebPage","@id":"https://andreynautilus.github.io/posts/2024-07-21-evenly-random-points-on-plane/"},"publisher":{"@type":"Organization","name":"Andrey Nautilus blog","logo":{"@type":"ImageObject","url":"https://andreynautilus.github.io/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://andreynautilus.github.io/ accesskey=h title="Andrey Nautilus blog (Alt + H)"><img src=https://andreynautilus.github.io/apple-touch-icon.png alt aria-label=logo height=35>Andrey Nautilus blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://andreynautilus.github.io/links/ title=links><span>links</span></a></li><li><a href=https://andreynautilus.github.io/tags/ title=tags><span>tags</span></a></li><li><a href=https://andreynautilus.github.io/search/ title="search (Alt + /)" accesskey=/><span>search</span></a></li><li><a href=https://github.com/AndreyNautilus/AndreyNautilus.github.io title=src><span>src</span>&nbsp;
<svg fill="none" shape-rendering="geometricPrecision" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2.5" viewBox="0 0 24 24" height="12" width="12"><path d="M18 13v6a2 2 0 01-2 2H5a2 2 0 01-2-2V8a2 2 0 012-2h6"/><path d="M15 3h6v6"/><path d="M10 14 21 3"/></svg></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://andreynautilus.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://andreynautilus.github.io/posts/>posts</a></div><h1 class="post-title entry-hint-parent">Evenly distributed random points</h1><div class=post-meta><span title='2024-07-21 20:16:16 +0200 +0200'>July 21, 2024</span>&nbsp;·&nbsp;3 min</div></header><div class=post-content><h2 id=random-points-on-a-plane>&ldquo;Random&rdquo; points on a plane<a hidden class=anchor aria-hidden=true href=#random-points-on-a-plane>#</a></h2><p>We need to generate random, <em>evenly distributed</em> points on a plane.
Possible use-cases:</p><ul><li>generate trees in a forest in a game world;</li><li>generate points for <a href=https://en.wikipedia.org/wiki/Voronoi_diagram>Voronoi diagram</a>
(with areas of similar size);</li></ul><p>The simplest approach - to use uniformly distributed points with <code>(random(), random())</code> - doesn&rsquo;t work,
because there will be areas with high density of points and areas with no points at all.
Such distribution doesn&rsquo;t look <em>natural</em>.</p><div style=text-align:center><svg id="uniform_distribution" style="width:100%;height:auto;max-width:700px" width="700" height="400" viewBox="0 0 700 400"></svg><p style=font-size:.85em><span id=uniform_distribution_num_points style=display:inline>NNNN</span> points</p></div><script type=module>

const numPoints = 1700;
document.getElementById('uniform_distribution_num_points').innerText = `${numPoints}`;

function renderSVG_UniformDistribution() {
  const svgns = 'http://www.w3.org/2000/svg';
  let svg = document.getElementById('uniform_distribution');

  // clear existing points
  while (svg.firstChild) {
    svg.removeChild(svg.firstChild);
  }

  const points = generatePointsByUniformDistribution(
    svg.getAttribute('width'),
    svg.getAttribute('height'),
    numPoints);

  for (let [x, y] of points) {
    let circle = document.createElementNS(svgns, 'circle');
    circle.setAttribute('cx', x);
    circle.setAttribute('cy', y);
    circle.setAttribute('r', 2);
    circle.setAttribute('style', 'fill: var(--primary)');
    svg.appendChild(circle);
  }
}

function generatePointsByUniformDistribution(width, height, amount) {
  let result = [];
  for (let i = 0; i < amount; i++) {
    result.push([Math.random() * width, Math.random() * height]);
  }
  return result;
}

document.getElementById('uniform_distribution').addEventListener('click', renderSVG_UniformDistribution);

renderSVG_UniformDistribution();

</script><p>Various types of grids with gaps can give even distribution, but the picture will not look <em>random</em>.
There will always be a pattern, sometimes more visible, sometimes less, but still visible. This
doesn&rsquo;t look <em>natural</em> either.</p><p>A solution to this problem is <a href=https://en.wikipedia.org/wiki/Supersampling#Poisson_disk>Poisson disk sampling (or Poisson disk distribution)</a>:
points are placed randomly, but not too close and not too far away from each other.</p><div style=text-align:center><svg id="poisson_disk_dist" style="width:100%;height:auto;max-width:700px" width="700" height="400" viewBox="0 0 700 400"></svg><p style=font-size:.85em><span id=poisson_disk_dist_num_points style=display:inline>NNNN</span> points</p></div><script type=module>
function renderSVG_PoissonDiskDistribution() {
  const svgns = 'http://www.w3.org/2000/svg';

  let svg = document.getElementById('poisson_disk_dist');

  const radius = 10;

  // clear existing points
  while (svg.firstChild) {
    svg.removeChild(svg.firstChild);
  }

  const points = generatePointsByPoissonDiskDistribution(
    svg.getAttribute('width'),
    svg.getAttribute('height'),
    radius);
  document.getElementById('poisson_disk_dist_num_points').innerText = `${points.length}`;

  for (let [x, y] of points) {
    let circle = document.createElementNS(svgns, 'circle');
    circle.setAttribute('cx', x);
    circle.setAttribute('cy', y);
    circle.setAttribute('r', 2);
    circle.setAttribute('style', 'fill: var(--primary)');
    svg.appendChild(circle);
  }
}

// Inspired by https://gist.github.com/mbostock/19168c663618b7f07158
function generatePointsByPoissonDiskDistribution(width, height, radius) {
  const k = 30;  // maximum number of candidates before rejecting an active point

  const cellSize = radius * Math.SQRT1_2;
  const gridWidth = Math.ceil(width / cellSize);
  const gridHeight = Math.ceil(height / cellSize);
  let grid = new Array(gridWidth * gridHeight);
  grid.fill(undefined);

  const radiusSq = radius * radius;

  let activePoints = [];

  let result = [];

  // generate the first point
  result.push(addPointXY(Math.random() * width, Math.random() * height));

  // pick a random point from Active Points
  while (activePoints.length > 0) {
    const activePointIndex = Math.random() * activePoints.length | 0;
    const activePoint = activePoints[activePointIndex];

    // generate candidates between [radius, 2 * radius] from the chosen active point
    let pointAdded = false;
    for (let i = 0; i < k; ++i) {
      const p = generatePointInAnnulus(activePoint);

      // pick the first acceptable candidate
      if (isPointWithinBorders(p) && isFarFromOthers(p)) {
        result.push(addPoint(p));
        pointAdded = true;
        break;
      }
    }

    // remove the point from Active Points if no new points were added
    if (!pointAdded) {
      activePoints.splice(activePointIndex, 1);
    }
  }

  return result;

  // generate a random point in [radius, 2 * radius] annulus from the center
  function generatePointInAnnulus(center) {
    const angle = 2 * Math.PI * Math.random();
    const distance = Math.sqrt(Math.random() * 3 * radiusSq + radiusSq);

    const x = center[0] + distance * Math.cos(angle);
    const y = center[1] + distance * Math.sin(angle);
    return [x, y]
  }

  function isPointWithinBorders(p) {
    return (0 <= p[0] && p[0] < width && 0 <= p[1] && p[1] < height);
  }

  function isFarFromOthers(p) {
    const cell = gridCellByPoint(p);

    const colMin = Math.max(cell[0] - 2, 0);
    const colMax = Math.min(cell[0] + 3, gridWidth);

    const rawMin = Math.max(cell[1] - 2, 0);
    const rawMax = Math.min(cell[1] + 3, gridHeight);

    for (let j = rawMin; j < rawMax; ++j) {
      for (let i = colMin; i < colMax; ++i) {
        const gridPoint = grid[gridIndexByCell([i, j])];
        if (gridPoint != undefined && distanceSq(gridPoint, p) < radiusSq) {
          return false;
        }
      }
    }

    return true;
  }

  function distanceSq(p1, p2) {
    const dx = p2[0] - p1[0];
    const dy = p2[1] - p1[1];
    return dx * dx + dy * dy;
  }

  function gridCellByPoint(p) {
    return [
      p[0] / cellSize | 0,
      p[1] / cellSize | 0];
  }

  function gridIndexByPoint(p) {
    const cell = gridCellByPoint(p);
    return gridIndexByCell(cell);
  }

  function gridIndexByCell(c) {
    return gridWidth * c[1] + c[0];
  }

  function addPointXY(x, y) {
    return addPoint([x, y]);
  }

  function addPoint(p) {
    activePoints.push(p);
    grid[gridIndexByPoint(p)] = p;
    return p;
  }
}

document.getElementById('poisson_disk_dist').addEventListener('click', renderSVG_PoissonDiskDistribution);

renderSVG_PoissonDiskDistribution()

</script><p><a href=https://bost.ocks.org/mike/algorithms/>This article</a> compares randomly placed points with
Poisson disk distribution, and shows &ldquo;best candidate&rdquo; and <a href=https://www.cs.ubc.ca/~rbridson/docs/bridson-siggraph07-poissondisk.pdf>Bridson’s</a>
algorithms to build such distribution (with great examples and visualizations).</p><h2 id=bridsons-algorithm-for-poisson-disk-sampling>Bridson’s algorithm for Poisson disk sampling<a hidden class=anchor aria-hidden=true href=#bridsons-algorithm-for-poisson-disk-sampling>#</a></h2><p>Summary of <a href=https://sighack.com/post/poisson-disk-sampling-bridsons-algorithm>this page</a>.
Bridson&rsquo;s algorithm allows us to generate random points with Poisson disk distribution.</p><p>Formal problem description: generate tightly packed random points maintaining minimal distance between them.</p><p>Algorithm parameters:</p><ol><li>area where points should be generated;</li><li><code>r</code> - minimum distance between any 2 points;</li><li><code>k</code> - amount of attempts to generate a new point;</li></ol><p>The algorithm uses a grid with <code>r/sqrt(2)</code> cell size. There could be at most 1 point in any grid cell.
The value of a cell is either an index of a generated point or <code>-1</code>.</p><p>The algorithm:</p><ol><li>initialize <em>the grid</em> that covers the requested area with <code>-1</code> in each cell;</li><li>generate an initial point <code>p0</code> and set the corresponding grid cell to <code>0</code> (the first point);
initialize a list of <em>active points</em> with index <code>0</code>;</li><li>pick a random index from <em>active points</em> (let&rsquo;s say <code>p-i</code>). Generate up to <code>k</code> random points in annulus between <code>r</code>
and <code>2r</code> form the selected point <code>p-i</code>; test every generated point if it&rsquo;s far enough (<code>dist >=r</code>)
from already existing points (use the grid to test only nearby cells);<ul><li>if a generated point is far enough from all existing points, add it to the list of <em>generated points</em>,
update the <em>grid cell</em> with its index and add this new point to <em>active points</em>;</li><li>if all <code>k</code> points are too close to already existing points, then remove <code>p-i</code> from <em>active points</em>;</li></ul></li><li>repeat until list of <em>active points</em> is empty;</li></ol><p>Side notes:</p><ul><li>complexity is <code>O(N)</code>;</li><li>easy to implement;</li><li>the cluster of points grows <em>naturally</em> from the starting point to all directions;</li><li>easily extensible to 3D (and more dimensional) space;</li><li>the number of points is not known until the generation process is complete (it&rsquo;s &ldquo;generate <em>some</em>
points with specific condition&rdquo; rather than &ldquo;generate N points&rdquo;);</li></ul><h2 id=links>Links<a hidden class=anchor aria-hidden=true href=#links>#</a></h2><ul><li><a href=https://www.jasondavies.com/poisson-disc/>https://www.jasondavies.com/poisson-disc/</a></li></ul></div><footer class=post-footer><ul class=post-tags><li><a href=https://andreynautilus.github.io/tags/procedural-generation/>procedural generation</a></li></ul><nav class=paginav><a class=prev href=https://andreynautilus.github.io/posts/2024-07-29-random-points-in-circle/><span class=title>« Prev</span><br><span>Random points in circle with uniform distribution</span>
</a><a class=next href=https://andreynautilus.github.io/posts/2024-07-16-linux-process-memory/><span class=title>Next »</span><br><span>Linux process memory: RSS, VSZ, etc</span></a></nav></footer></article></main><footer class=footer><span>&copy; 2025 <a href=https://andreynautilus.github.io/>Andrey Nautilus blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>
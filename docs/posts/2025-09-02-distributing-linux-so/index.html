<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Build linux shared libraries for distribution | Andrey Nautilus blog</title><meta name=keywords content="C++,shared library,cmake"><meta name=description content="Build the library, strip debug info, manage symbols visibility, etc."><meta name=author content><link rel=canonical href=https://andreynautilus.github.io/posts/2025-09-02-distributing-linux-so/><link crossorigin=anonymous href=/assets/css/stylesheet.8fe10233a706bc87f2e08b3cf97b8bd4c0a80f10675a143675d59212121037c0.css integrity="sha256-j+ECM6cGvIfy4Is8+XuL1MCoDxBnWhQ2ddWSEhIQN8A=" rel="preload stylesheet" as=style><link rel=icon href=https://andreynautilus.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://andreynautilus.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://andreynautilus.github.io/favicon-32x32.png><link rel=apple-touch-icon href=https://andreynautilus.github.io/apple-touch-icon.png><link rel=mask-icon href=https://andreynautilus.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://andreynautilus.github.io/posts/2025-09-02-distributing-linux-so/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script type=text/javascript>(function(e,t,n,s,o,i,a){e[o]=e[o]||function(){(e[o].a=e[o].a||[]).push(arguments)},e[o].l=1*new Date;for(var r=0;r<document.scripts.length;r++)if(document.scripts[r].src===s)return;i=t.createElement(n),a=t.getElementsByTagName(n)[0],i.async=1,i.src=s,a.parentNode.insertBefore(i,a)})(window,document,"script","https://mc.yandex.ru/metrika/tag.js","ym"),ym(99367858,"init",{clickmap:!0,trackLinks:!0,accurateTrackBounce:!0})</script><noscript><div><img src=https://mc.yandex.ru/watch/99367858 style=position:absolute;left:-9999px alt></div></noscript><script async src="https://www.googletagmanager.com/gtag/js?id=G-S584PB390B"></script><script>window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-S584PB390B")</script><link rel=stylesheet href=/css/global/builtin_icon.min.af7971272ac3da29f13218095878a0d6404d665d4c1192b7bfc4cc894d4eb76a.css integrity="sha256-r3lxJyrD2inxMhgJWHig1kBNZl1MEZK3v8TMiU1Ot2o=" as=style><link rel=stylesheet href=/css/global/card_tags.min.08b084a05dddb2ae47b67783718d65c42eecc00cfee8c93fc63800741d66cc86.css integrity="sha256-CLCEoF3dsq5HtneDcY1lxC7swAz+6Mk/xjgAdB1mzIY=" as=style><link rel=stylesheet href=/css/global/columns.min.ad3ed875afa77918f5cc0b00a353ef761e69cccbe846e275bea3a8411ef7bd31.css integrity="sha256-rT7Yda+neRj1zAsAo1Pvdh5pzMvoRuJ1vqOoQR73vTE=" as=style><meta property="og:url" content="https://andreynautilus.github.io/posts/2025-09-02-distributing-linux-so/"><meta property="og:site_name" content="Andrey Nautilus blog"><meta property="og:title" content="Build linux shared libraries for distribution"><meta property="og:description" content="Build the library, strip debug info, manage symbols visibility, etc."><meta property="og:locale" content="en"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2025-09-02T19:33:30+02:00"><meta property="article:modified_time" content="2025-09-02T19:33:30+02:00"><meta property="article:tag" content="C++"><meta property="article:tag" content="shared library"><meta property="article:tag" content="cmake"><meta name=twitter:card content="summary"><meta name=twitter:title content="Build linux shared libraries for distribution"><meta name=twitter:description content="Build the library, strip debug info, manage symbols visibility, etc."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"posts","item":"https://andreynautilus.github.io/posts/"},{"@type":"ListItem","position":2,"name":"Build linux shared libraries for distribution","item":"https://andreynautilus.github.io/posts/2025-09-02-distributing-linux-so/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Build linux shared libraries for distribution","name":"Build linux shared libraries for distribution","description":"Build the library, strip debug info, manage symbols visibility, etc.","keywords":["C++","shared library","cmake"],"articleBody":"Imagine we’re developing a C++ library. We need to deliver this library to a client, and the agreement is to deliver it as a shared library for linux. How to do this?\nLet’s define the setup and assumptions:\nwe develop on linux system using well-known compiler, like gcc or clang; we use cmake as build system (backed by make or ninja); we know how to build for the target platform (for example the client provides a toolchain); the target platform may be different from the development platform, and the produced library may require an emulator to run. The setup for our example project includes:\nlibfoo is the library we need to deliver; app is our internal developer app that uses libfoo; The code of example project can be found here.\nBuild configuration cmake has a concept of Build Configurations which controls what options are passed to the compiler. There are 4 default configurations - Debug, Release, RelWithDebInfo and MinSizeRel - and CMAKE_BUILD_TYPE variable controls this.\nDebug - for development use only. No optimizations, debug info included. Release - produces the final deliverable binary. Optimized for speed, no debug info included. RelWithDebInfo - same as Release, but includes debug info. Debug info significantly increases the size of the binary, but allows to analyze crash dumps. MinSizeRel - similar to Release, but optimized for size of the binary rather than execution speed. We can consider shipping the library without debug info - Release or MinSizeRel configuration - if we don’t expect to receive and analyze crash dumps from the clients. If we do need to investigate crashes, we need debug symbols, but we also need optimizations, so RelWithDebInfo is our only option. But we don’t want to ship a library polluted with debug info.\nThe solution is to put debug info in a separate file.\nStrip the binary file command or readelf tool from binutils package can show if a binary contains debug info. Let’s build the library in RelWithDebInfo mode:\ncmake -DCMAKE_BUILD_TYPE=RelWithDebInfo -DBUILD_SHARED_LIBS=ON .. cmake --build . # build succeeds and inspect it:\n$ file libfoo.so libfoo.so: ELF 64-bit LSB shared object, ..., with debug_info, not stripped $ readelf --sections libfoo.so | grep debug ... [28] .debug_aranges PROGBITS 0000000000000000 000030b5 [29] .debug_info PROGBITS 0000000000000000 00003145 ... file prints with debug_info, and readelf --sections shows debug sections, which means the library contains debug symbols. If we would use -DCMAKE_BUILD_TYPE=Release, there would be no debug sections in readelf and file wouldn’t show with debug_info.\nobjcopy tool from binutils can copy debug info into a separate file:\nobjcopy --only-keep-debug libfoo.so libfoo.so.debug objcopy --strip-debug --add-gnu-debuglink=libfoo.so.debug libfoo.so cmake usually provides CMAKE_OBJCOPY variable that points to objcopy executable. We can use it to add a custom command to our cmake target and extract debug info during the build.\nIf we rebuild the library with LIBFOO_STRIP=ON:\n# `LIBFOO_STRIP` is a custom option in the example project cmake -DCMAKE_BUILD_TYPE=RelWithDebInfo -DBUILD_SHARED_LIBS=ON -DLIBFOO_STRIP=ON .. cmake --build . # build succeeds and inspect the produced binary:\n$ file libfoo.so libfoo.so: ELF 64-bit LSB shared object, ..., not stripped $ readelf --sections libfoo.so | grep debug [28] .gnu_debuglink PROGBITS 0000000000000000 000030b8 readelf shows .gnu_debuglink section only which is a link to a file containing debug info (caused by --add-gnu-debuglink option in the example project). file doesn’t show with debug_info, but still shows not stripped - this means that our binary still contains additional unneeded info - for example .symtab section. Unneeded sections can be removed if objcopy is invoked with --strip-unneeded parameter instead of --strip-debug.\ncmake --install has --strip option which performs such aggressive stripping during installation. If we use it after the build:\n# `LIBFOO_STRIP` is a custom option in the example project cmake -DCMAKE_BUILD_TYPE=RelWithDebInfo -DBUILD_SHARED_LIBS=ON -DLIBFOO_STRIP=ON .. cmake --build . # build succeeds ctest cmake --install . --prefix=../out --strip and inspect the produced and installed binaries, we’ll see that the installed binary is finally stripped:\n$ file libfoo.so libfoo.so: ELF 64-bit LSB shared object, ..., not stripped $ file ../out/lib/libfoo.so ../out/lib/libfoo.so: ELF 64-bit LSB shared object, ..., stripped We need to save the file with debug info (libfoo.so.debug) for every shipped binary, then we will be able to analyze crash dumps that customers may send to us.\nVisibility of exported symbols Shared libraries provide functionality via exported dynamic symbols. If we build libfoo as shared in Release mode:\ncmake -DCMAKE_BUILD_TYPE=Release -DBUILD_SHARED_LIBS=ON .. cmake --build . # build succeeds ctest # tests run successfully we’ll get libfoo.so as our shared library. To list dynamic symbols we can use nm tool from binutils package:\n$ nm --dynamic libfoo.so # or \"nm -D\" ... w _ITM_registerTMCloneTable U _Unwind_Resume@GCC_3.0 00000000000012c0 T _ZN6libfoo3fooEv 00000000000013d0 T _ZN6libfoo4foo2Ev 0000000000001450 T _ZN6libfoo8internal12foo_internalB5cxx11Ev U _ZNKSt5ctypeIcE13_M_widen_initEv@GLIBCXX_3.4.11 0000000000001440 W _ZNKSt5ctypeIcE8do_widenEc U _ZNSo3putEc@GLIBCXX_3.4 U _ZNSo5flushEv@GLIBCXX_3.4 ... Looking at this list, there are 2 observations that raise questions:\nthis list contains “ugly” names instead of pretty C++ names. This is called name mangling and compilers do this to C++ symbols to make them unique. We can add --demangle parameter to nm to get pretty symbols back: $ nm --dynamic --demangle libfoo.so # or \"nm -DC\" ... w _ITM_registerTMCloneTable U _Unwind_Resume@GCC_3.0 00000000000012c0 T libfoo::foo() 00000000000013d0 T libfoo::foo2() 0000000000001450 T libfoo::internal::foo_internal[abi:cxx11]() U std::ctype::_M_widen_init() const@GLIBCXX_3.4.11 0000000000001440 W std::ctype::do_widen(char) const U std::ostream::put(char)@GLIBCXX_3.4 U std::ostream::flush()@GLIBCXX_3.4 ... Another option is c++filt tool from binutils: nm --dynamic libfoo.so | c++filt will give similar output. there are way too many symbols in the list including our internal symbols (libfoo::internal::foo_internal) and symbols from library dependencies (std::ostream::flush()). This happens because by default all statically linked symbols are visible and exported from dynamic libraries. Users of the library can try to use these symbols which is undesirable. We need to limit symbols visibility to keep the public library API clean. Let’s inspect nm output in more details. Symbols with address in the first column are “real” symbols exported from the library. Users that link against our library can use these symbols (call the functions) freely. The second column is the type of the symbol. What’s important for now:\nU means “undefined symbol” - the symbol is required, and must be provided at runtime via dependencies (note @GLIBCXX_3.4 suffix for example). T means global symbol “in .text section” - exported from the library. t also means a symbol “in .text section”, but it’s local and not exported (nm --dynamic doesn’t show them). w/W means “weak symbol”. When linking the final application, the linker will pick a non-weak symbol over weak symbols, and pick any weak symbol if no non-weak symbols exist. Typically, weak symbols are default constructors/destructors and templates instantiations. They don’t violate ODR rule, and the linker will eliminate duplicates. Our goal is to have all symbols forming public API of our library to be exported (in dynamic section), and no other internal symbols should be exported.\nPass “version script” file to linker Widely used linkers (like GNU ld and gold or LLVM lld) support version script files via --version-script parameter. Version script files can be used to define visibility of symbols. An example of such file to export symbols from libfoo:: namespace only can look like this:\n{ global: _ZN6libfoo*; local: *; }; This file uses mangled symbol names, so we need know them upfront (by running nm for example).\nTo pass a version script file to the linker we need to add -Wl,--version-script=FILENAME linker option (or add this flag to LINK_FLAGS property of the cmake target). Let’s build the library and inspect exported symbols:\n# `LIBFOO_USE_VERSION_SCRIPT` is a custom option in the example project cmake -DCMAKE_BUILD_TYPE=Release -DBUILD_SHARED_LIBS=ON -DLIBFOO_USE_VERSION_SCRIPT=ON .. cmake --build . ctest nm --dynamic --demangle libfoo.so ... U _Unwind_Resume@GCC_3.0 00000000000012c0 T libfoo::foo() 00000000000013d0 T libfoo::foo2() 0000000000001450 T libfoo::internal::foo_internal[abi:cxx11]() U std::ctype::_M_widen_init() const@GLIBCXX_3.4.11 ... We see that only symbols from libfoo:: namespace(s) are exported. But internal symbols from libfoo::internal:: namespace are also exported, which we want to avoid.\nAnd here comes the problem: it’s not possible to refine the filter by adding libfoo::internal::* in the local section:\n{ global: _ZN6libfoo*; local: _ZN6libfoo8internal*; # won't work :( *; }; If a symbol matches any wild-star pattern in global section, this symbol will not be checked against patterns in local section.\nOne potential way to overcome this limitation is to list all symbols we want to export explicitly, but that’s a tedious work. A script to fetch symbols from nm output can be handy, but requires additional effort.\nPros: no code changes required. Configuration lives in a separate file which can be dynamically created or adjusted.\nCons: limitation for visibility of nested namespaces.\nExplicitly annotate exported symbols A better way is to tell linker to hide all symbols by default and explicitly annotate symbols we want to export. Use -fvisibility=hidden linker flag (or set CXX_VISIBILITY_PRESET hidden cmake property) to make all symbols hidden by default.\n__attribute__((visibility(\"default\"))) annotation (for GCC and clang) marks symbols for exporting. We can define a macro to avoid typing it every time:\n#define PUBLIC_API_FOO __attribute__((visibility(\"default\"))) PUBLIC_API_FOO void foo(); It’s a common practice to annotate symbols in public header files, but these headers are also usually shipped to customers, and customers don’t need this annotation in their code. This macro needs to be defined to nothing when used outside of our build system. cmake automatically provides _EXPORTS compiler definition when a library is built as shared, so we can use it:\n#ifdef foo_EXPORTS # define PUBLIC_API_FOO __attribute__((visibility(\"default\"))) #else # define PUBLIC_API_FOO #endif PUBLIC_API_FOO void foo(); If we now build the library and inspect exported symbols:\n# `LIBFOO_API_VISIBILITY` is a custom option in the example project cmake -DCMAKE_BUILD_TYPE=Release -DBUILD_SHARED_LIBS=ON -DLIBFOO_API_VISIBILITY=ON .. cmake --build . ctest nm --dynamic --demangle libfoo.so ... U _Unwind_Resume@GCC_3.0 00000000000012a0 T libfoo::foo() U std::ctype::_M_widen_init() const@GLIBCXX_3.4.11 ... we’ll see that only annotated symbols are exported.\nNote: Don’t forget to #include public headers that define exported symbols into compilable files (cpp/cxx/cc). If a header file is never included in any translation unit, it’s not processed and effectively ignored.\nPros: all exported symbols are explicitly annotated. It’s a conscious decision and low risk of mistakes.\nCons:\npublic headers are “polluted” with PUBLIC_API_FOO macro, which is meaningless for clients; if different clients need to have access to different set of symbols, this approach requires bulky fine-tuning (for example, split API into categories and export different categories for different customers); Exported symbols and testing Hidden symbols are not visible for the users of the library. Tests (unit tests, components test, etc) are also users of the library, they cannot access hidden symbols.\nShared libraries need well-written interface tests to verify the produced binary. The rest of the testing can be performed on a dedicated build that doesn’t hide symbols.\nDependencies Shared libraries as any other binaries may have dependencies on other shared libraries. readelf tool can show what dependencies our library has. Let’s build libfoo:\ncmake -DCMAKE_BUILD_TYPE=Release -DBUILD_SHARED_LIBS=ON .. cmake --build . # build succeeds and inspect the produced library:\n$ readelf --dynamic libfoo.so Tag Type Name/Value 0x0000000000000001 (NEEDED) Shared library: [libstdc++.so.6] 0x0000000000000001 (NEEDED) Shared library: [libgcc_s.so.1] 0x0000000000000001 (NEEDED) Shared library: [libc.so.6] 0x000000000000000e (SONAME) Library soname: [libfoo.so] ... NEEDED records are shared libraries that our library depends on.\nAlternatively we can use ldd tool to print all (including transitive) shared dependencies. ldd is a runtime tool: it actually invokes the dynamic linker to find dependencies, so it might not always work (for example if the library is cross-compiled for another architecture).\n$ ldd libfoo.so linux-vdso.so.1 (0x00007ffc04386000) libstdc++.so.6 =\u003e /lib/x86_64-linux-gnu/libstdc++.so.6 (0x00007734bbc00000) libgcc_s.so.1 =\u003e /lib/x86_64-linux-gnu/libgcc_s.so.1 (0x00007734bbe9e000) libc.so.6 =\u003e /lib/x86_64-linux-gnu/libc.so.6 (0x00007734bb800000) libm.so.6 =\u003e /lib/x86_64-linux-gnu/libm.so.6 (0x00007734bbb19000) /lib64/ld-linux-x86-64.so.2 (0x00007734bbeca000) If our library depends on another our library, we have to ship this dependency along with the library itself. A better way is statically link dependencies into the final shared library, that will simplify management a lot, but in some cases it’s not possible or allowed.\nNote: I’m talking about first-party dependencies (dependencies that we as developers produce). System dependencies should not be statically linked or packaged with the deliverables. Third-party dependencies (like openssl) can follow both approaches and they should be handled on case-by-case basis.\nWhen cmake --build produces a library it embeds full paths to dependencies as RUNPATH records:\nreadelf --dynamic ...so ... 0x0000000000000001 (NEEDED) Shared library: [libbar.so] 0x000000000000001d (RUNPATH) Library runpath: [/home/andrey/projects/learning-playground/linux-shared-lib/build/libbar:] ... which allows any executable in the project (tests or apps) to run without additional configuration, but that’s not portable. cmake --install strips these records and leaves just NEEDED record for each dependency:\nreadelf --dynamic installed/...so ... 0x0000000000000001 (NEEDED) Shared library: [libbar.so] This moves the responsibility to provide runtime search paths to the final application. The clients application may be shipped along with its dependencies, or can be an application that expects dependencies to be in specific locations within the application bundle (like Android APK for example). In such cases better let the client deal with search paths.\nNote: there’s a very good talk “C++ Shared Libraries and Where To Find Them” that explains RPATH/RUNPATH handling at compile time and runtime.\nABI versioning via SONAME readelf --dynamic shows SONAME record, which contains a value similar to the filename of the shared library. This value will be embedded into the client application as dynamic dependency when the app is linked against our library. Even though the app links against libfoo.so during the build, at runtime the app will look for a file with the name taken from SONAME record of libfoo.so.\nThis mechanism allows updates of libraries without rebuilding client applications. Libraries that use ABI version management are usually shipped with symlinks, for example:\nlibfoo.so -\u003e libfoo.so.1 # symlink libfoo.so.1 -\u003e libfoo.so.1.0.0 # symlink libfoo.so.1.0.0 # actual library file and SONAME record of the library contains libfoo.so.1. When an app is linked against libfoo.so, at runtime this app will look for libfoo.so.1 file (value of SONAME record). This allows users to update libfoo to version 1.0.1 or 1.1.0 and the app will continue to work (as long as the update process updates symlinks: libfoo.so.1 -\u003e libfoo.so.1.1.0). Users can even install multiple major versions of the same library (1.1.0 and 2.0.0) and apps will be able to find the correct dependency at runtime (one app that depends on libfoo.so.1 will pick libfoo.so.1.1.0 while another app that depends on libfoo.so.2 will pick libfoo.so.2.0.0).\nNote: it’s the responsibility of the library authors to actually maintain ABI compatibility.\nIn cmake this can be configured via VERSION and SOVERSION properties. Let’s build libfoo:\n# `LIBFOO_VERSIONING` is a custom option in the example project cmake -DCMAKE_BUILD_TYPE=RelWithDebInfo -DBUILD_SHARED_LIBS=ON -DLIBFOO_VERSIONING=ON .. cmake --build . and inspect the produced files:\n$ ls -la *.so* lrwxrwxrwx 1 user user 11 Sep 2 19:56 libfoo.so -\u003e libfoo.so.1* lrwxrwxrwx 1 user user 15 Sep 2 19:56 libfoo.so.1 -\u003e libfoo.so.1.2.3* -rwxr-xr-x 1 user user 106840 Sep 2 19:56 libfoo.so.1.2.3* $ readelf --dynamic libfoo.so | grep SONAME 0x000000000000000e (SONAME) Library soname: [libfoo.so.1] If an app is linked against libfoo.so, it will depend at runtime on libfoo.so.1:\n$ readelf --dynamic ./app ... 0x0000000000000001 (NEEDED) Shared library: [libfoo.so.1] ... This might be useful if the shared library that we deliver may be updated on-the-fly, and client apps must continue to work. If the client app is used as a single package and library updates can’t happen (for example if our library is packaged in an Android APK file), this versioning can be safely ignored.\nUsage When clients want to use our library, they need to link against libfoo.so and add the path to public headers of our library to their include path.\ncmake has a concept of imported targets for this purpose:\nadd_library(foo SHARED IMPORTED) set_target_properties(foo PROPERTIES IMPORTED_LOCATION path/to/libfoo.so IMPORTED_SONAME libfoo.so ) target_include_directories(foo INTERFACE path/to/libfoo/headers) IMPORTED_SONAME property must match SONAME record in libfoo.so. After that foo target can be used as any other target:\ntarget_link_libraries(app PRIVATE foo) Let’s build and install libfoo:\ncd libfoo/build cmake -DCMAKE_BUILD_TYPE=Release -DBUILD_SHARED_LIBS=ON -DLIBFOO_API_VISIBILITY=ON -DLIBFOO_STRIP=ON .. cmake --build . # build succeeds ctest # tests run and pass - the library is usable cmake --install . --prefix=../out --strip # install libfoo into 'libfoo/out' build the app:\ncd app/build # `LIBFOO_BASE_DIR` is a custom option in the example project cmake -DCMAKE_BUILD_TYPE=Release -DLIBFOO_BASE_DIR=../libfoo/out .. cmake --build . ./app # runs and prints output and inspect the executable:\n$ readelf --dynamic app ... 0x0000000000000001 (NEEDED) Shared library: [libfoo.so] 0x000000000000001d (RUNPATH) Library runpath: [/home/andrey/projects/learning-playground/linux-shared-lib/libfoo/out/lib:] ... $ ldd app linux-vdso.so.1 (0x00007ffe6416f000) libfoo.so =\u003e /home/andrey/projects/learning-playground/linux-shared-lib/libfoo/out/lib/libfoo.so (0x0000771d1f915000) ... This is the executable in the cmake build tree, it contains RUNPATH to locate the exact library it was linked with.\nTo make this application portable, it needs to be installed via cmake --install:\ncmake --install . --prefix=../out --strip readelf --dynamic ../out/bin/app ... 0x0000000000000001 (NEEDED) Shared library: [libfoo.so] 0x0000000000000001 (NEEDED) Shared library: [libstdc++.so.6] 0x0000000000000001 (NEEDED) Shared library: [libc.so.6] ... It has no RPATH/RUNPATH records by default. If we try to run the app, it will fail:\n$ ../out/bin/app ../out/bin/app: error while loading shared libraries: libfoo.so: cannot open shared object file: No such file or directory And that’s expected, because libfoo.so is not in any standard search path of the system. We need to either explicitly set relative RPATH for the application during the build and put our libraries there, or use LD_LIBRARY_PATH environment variable:\nlinux-shared-lib$ LD_LIBRARY_PATH=libfoo/out/lib/ ./app/out/bin/app Hello world! cmake project for the client application can be configured to also copy shared libraries from dependencies, copy debug info files, and more, but that’s out of scope for this page.\nReferences StackOverflow: What are CMAKE_BUILD_TYPE: Debug, Release, RelWithDebInfo and MinSizeRel? Controlling the Exported Symbols of Shared Libraries Stripped binaries (wiki) C++ Shared Libraries and Where To Find Them GNU Wiki: Visibility attribute ","wordCount":"2892","inLanguage":"en","datePublished":"2025-09-02T19:33:30+02:00","dateModified":"2025-09-02T19:33:30+02:00","mainEntityOfPage":{"@type":"WebPage","@id":"https://andreynautilus.github.io/posts/2025-09-02-distributing-linux-so/"},"publisher":{"@type":"Organization","name":"Andrey Nautilus blog","logo":{"@type":"ImageObject","url":"https://andreynautilus.github.io/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://andreynautilus.github.io/ accesskey=h title="Andrey Nautilus blog (Alt + H)"><img src=https://andreynautilus.github.io/apple-touch-icon.png alt aria-label=logo height=35>Andrey Nautilus blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://andreynautilus.github.io/links/ title=links><span>links</span></a></li><li><a href=https://andreynautilus.github.io/tags/ title=tags><span>tags</span></a></li><li><a href=https://andreynautilus.github.io/search/ title="search (Alt + /)" accesskey=/><span>search</span></a></li><li><a href=https://github.com/AndreyNautilus/AndreyNautilus.github.io title=src><span>src</span>&nbsp;
<svg fill="none" shape-rendering="geometricPrecision" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2.5" viewBox="0 0 24 24" height="12" width="12"><path d="M18 13v6a2 2 0 01-2 2H5a2 2 0 01-2-2V8a2 2 0 012-2h6"/><path d="M15 3h6v6"/><path d="M10 14 21 3"/></svg></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://andreynautilus.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://andreynautilus.github.io/posts/>posts</a></div><h1 class="post-title entry-hint-parent">Build linux shared libraries for distribution</h1><div class=post-meta><span title='2025-09-02 19:33:30 +0200 +0200'>September 2, 2025</span>&nbsp;·&nbsp;14 min</div></header><div class=toc><details open><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><nav id=TableOfContents><ul><li><a href=#build-configuration>Build configuration</a><ul><li><a href=#strip-the-binary>Strip the binary</a></li></ul></li><li><a href=#visibility-of-exported-symbols>Visibility of exported symbols</a><ul><li><a href=#pass-version-script-file-to-linker>Pass &ldquo;version script&rdquo; file to linker</a></li><li><a href=#explicitly-annotate-exported-symbols>Explicitly annotate exported symbols</a></li><li><a href=#exported-symbols-and-testing>Exported symbols and testing</a></li></ul></li><li><a href=#dependencies>Dependencies</a></li><li><a href=#abi-versioning-via-soname>ABI versioning via SONAME</a></li><li><a href=#usage>Usage</a></li><li><a href=#references>References</a></li></ul></nav></div></details></div><div class=post-content><p>Imagine we&rsquo;re developing a C++ library. We need to deliver this library to a client,
and the agreement is to deliver it as a <em>shared library</em> for linux. How to do this?</p><p>Let&rsquo;s define the setup and assumptions:</p><ul><li>we develop on linux system using well-known compiler, like gcc or clang;</li><li>we use cmake as build system (backed by make or ninja);</li><li>we know how to build for the target platform (for example the client provides a toolchain);</li><li>the target platform may be different from the development platform,
and the produced library may require an emulator to run.</li></ul><p>The setup for our example project includes:</p><ul><li><code>libfoo</code> is the library we need to deliver;</li><li><code>app</code> is our internal developer app that uses <code>libfoo</code>;</li></ul><p>The code of example project can be found <a href=https://github.com/AndreyNautilus/learning-playground/tree/main/linux-shared-lib>here</a>.</p><h2 id=build-configuration>Build configuration<a hidden class=anchor aria-hidden=true href=#build-configuration>#</a></h2><p><code>cmake</code> has a concept of <a href=https://cmake.org/cmake/help/latest/manual/cmake-buildsystem.7.html#build-configurations>Build Configurations</a>
which controls what options are passed to the compiler.
There are <a href=https://stackoverflow.com/questions/48754619/what-are-cmake-build-type-debug-release-relwithdebinfo-and-minsizerel/59314670#59314670>4 default configurations</a> -
<code>Debug</code>, <code>Release</code>, <code>RelWithDebInfo</code> and <code>MinSizeRel</code> -
and <code>CMAKE_BUILD_TYPE</code> <a href=https://cmake.org/cmake/help/latest/variable/CMAKE_BUILD_TYPE.html>variable</a>
controls this.</p><ul><li><strong>Debug</strong> - for development use only. No optimizations, debug info included.</li><li><strong>Release</strong> - produces the final deliverable binary. Optimized for speed, no debug info included.</li><li><strong>RelWithDebInfo</strong> - same as Release, but includes debug info. Debug info significantly increases
the size of the binary, but allows to analyze crash dumps.</li><li><strong>MinSizeRel</strong> - similar to Release, but optimized for size of the binary rather than execution speed.</li></ul><p>We can consider shipping the library without debug info - <strong>Release</strong> or <strong>MinSizeRel</strong> configuration -
if we don&rsquo;t expect to receive and analyze crash dumps from the clients.
If we do need to investigate crashes, we need debug symbols, but we also need optimizations,
so <strong>RelWithDebInfo</strong> is our only option. But we don&rsquo;t want to ship a library polluted with
debug info.</p><p>The solution is to put debug info in a separate file.</p><h3 id=strip-the-binary>Strip the binary<a hidden class=anchor aria-hidden=true href=#strip-the-binary>#</a></h3><p><code>file</code> <a href=https://man7.org/linux/man-pages/man1/file.1.html>command</a> or
<code>readelf</code> <a href=https://www.man7.org/linux/man-pages/man1/readelf.1.html>tool</a>
from <code>binutils</code> <a href=https://www.gnu.org/software/binutils/>package</a> can show if a binary contains debug info.
Let&rsquo;s build the library in <strong>RelWithDebInfo</strong> <a href=https://cmake.org/cmake/help/latest/variable/CMAKE_BUILD_TYPE.html>mode</a>:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>cmake -DCMAKE_BUILD_TYPE<span class=o>=</span>RelWithDebInfo -DBUILD_SHARED_LIBS<span class=o>=</span>ON ..
</span></span><span class=line><span class=cl>cmake --build .  <span class=c1># build succeeds</span>
</span></span></code></pre></div><p>and inspect it:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>$ file libfoo.so
</span></span><span class=line><span class=cl>libfoo.so: ELF 64-bit LSB shared object, ..., with debug_info, not stripped
</span></span><span class=line><span class=cl>$ readelf --sections libfoo.so <span class=p>|</span> grep debug
</span></span><span class=line><span class=cl>...
</span></span><span class=line><span class=cl>  <span class=o>[</span>28<span class=o>]</span> .debug_aranges    PROGBITS         <span class=m>0000000000000000</span>  000030b5
</span></span><span class=line><span class=cl>  <span class=o>[</span>29<span class=o>]</span> .debug_info       PROGBITS         <span class=m>0000000000000000</span>  <span class=m>00003145</span>
</span></span><span class=line><span class=cl>...
</span></span></code></pre></div><p><code>file</code> prints <code>with debug_info</code>, and <code>readelf --sections</code> shows debug sections, which means
the library contains debug symbols. If we would use <code>-DCMAKE_BUILD_TYPE=Release</code>, there would be
no debug sections in <code>readelf</code> and <code>file</code> wouldn&rsquo;t show <code>with debug_info</code>.</p><p><code>objcopy</code> <a href=https://man7.org/linux/man-pages/man1/objcopy.1.html>tool</a> from <code>binutils</code> can
copy debug info into a separate file:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>objcopy --only-keep-debug libfoo.so libfoo.so.debug
</span></span><span class=line><span class=cl>objcopy --strip-debug --add-gnu-debuglink<span class=o>=</span>libfoo.so.debug libfoo.so
</span></span></code></pre></div><p><code>cmake</code> usually provides <code>CMAKE_OBJCOPY</code> <a href=https://cmake.org/cmake/help/latest/module/CPack.html#variable:CPACK_OBJCOPY_EXECUTABLE>variable</a>
that points to <code>objcopy</code> executable. We can use it to add a custom command to our <code>cmake</code> target
and extract debug info during the build.</p><p>If we rebuild the library with <code>LIBFOO_STRIP=ON</code>:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl><span class=c1># `LIBFOO_STRIP` is a custom option in the example project</span>
</span></span><span class=line><span class=cl>cmake -DCMAKE_BUILD_TYPE<span class=o>=</span>RelWithDebInfo -DBUILD_SHARED_LIBS<span class=o>=</span>ON -DLIBFOO_STRIP<span class=o>=</span>ON ..
</span></span><span class=line><span class=cl>cmake --build .  <span class=c1># build succeeds</span>
</span></span></code></pre></div><p>and inspect the produced binary:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>$ file libfoo.so
</span></span><span class=line><span class=cl>libfoo.so: ELF 64-bit LSB shared object, ..., not stripped
</span></span><span class=line><span class=cl>$ readelf --sections libfoo.so <span class=p>|</span> grep debug
</span></span><span class=line><span class=cl>  <span class=o>[</span>28<span class=o>]</span> .gnu_debuglink    PROGBITS         <span class=m>0000000000000000</span>  000030b8
</span></span></code></pre></div><p><code>readelf</code> shows <code>.gnu_debuglink</code> section only which is a link to a file containing debug info
(caused by <code>--add-gnu-debuglink</code> option in the example project). <code>file</code> doesn&rsquo;t show <code>with debug_info</code>,
but still shows <code>not stripped</code> - this means that our binary still contains additional unneeded info -
for example <code>.symtab</code> section. Unneeded sections can be removed if <code>objcopy</code> is invoked
with <code>--strip-unneeded</code> parameter instead of <code>--strip-debug</code>.</p><p><code>cmake --install</code> has <code>--strip</code> <a href=https://cmake.org/cmake/help/latest/manual/cmake.1.html#cmdoption-cmake-install-strip>option</a>
which performs such aggressive stripping during installation. If we use it after the build:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl><span class=c1># `LIBFOO_STRIP` is a custom option in the example project</span>
</span></span><span class=line><span class=cl>cmake -DCMAKE_BUILD_TYPE<span class=o>=</span>RelWithDebInfo -DBUILD_SHARED_LIBS<span class=o>=</span>ON -DLIBFOO_STRIP<span class=o>=</span>ON ..
</span></span><span class=line><span class=cl>cmake --build .  <span class=c1># build succeeds</span>
</span></span><span class=line><span class=cl>ctest
</span></span><span class=line><span class=cl>cmake --install . --prefix<span class=o>=</span>../out --strip
</span></span></code></pre></div><p>and inspect the <em>produced</em> and <em>installed</em> binaries, we&rsquo;ll see that the <em>installed</em> binary is finally stripped:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>$ file libfoo.so
</span></span><span class=line><span class=cl>libfoo.so: ELF 64-bit LSB shared object, ..., not stripped
</span></span><span class=line><span class=cl>$ file ../out/lib/libfoo.so
</span></span><span class=line><span class=cl>../out/lib/libfoo.so: ELF 64-bit LSB shared object, ..., stripped
</span></span></code></pre></div><p>We need to save the file with debug info (<code>libfoo.so.debug</code>) for every shipped binary, then we will be able
to analyze crash dumps that customers may send to us.</p><h2 id=visibility-of-exported-symbols>Visibility of exported symbols<a hidden class=anchor aria-hidden=true href=#visibility-of-exported-symbols>#</a></h2><p>Shared libraries provide functionality via <em>exported dynamic symbols</em>.
If we build <code>libfoo</code> as shared
in Release <a href=https://cmake.org/cmake/help/latest/variable/CMAKE_BUILD_TYPE.html>mode</a>:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>cmake -DCMAKE_BUILD_TYPE<span class=o>=</span>Release -DBUILD_SHARED_LIBS<span class=o>=</span>ON ..
</span></span><span class=line><span class=cl>cmake --build .  <span class=c1># build succeeds</span>
</span></span><span class=line><span class=cl>ctest  <span class=c1># tests run successfully</span>
</span></span></code></pre></div><p>we&rsquo;ll get <code>libfoo.so</code> as our shared library.
To list dynamic symbols we can use <code>nm</code> <a href=https://man7.org/linux/man-pages/man1/nm.1.html>tool</a>
from <code>binutils</code> <a href=https://www.gnu.org/software/binutils/>package</a>:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>$ nm --dynamic libfoo.so  <span class=c1># or &#34;nm -D&#34;</span>
</span></span><span class=line><span class=cl>...
</span></span><span class=line><span class=cl>                 w _ITM_registerTMCloneTable
</span></span><span class=line><span class=cl>                 U _Unwind_Resume@GCC_3.0
</span></span><span class=line><span class=cl>00000000000012c0 T _ZN6libfoo3fooEv
</span></span><span class=line><span class=cl>00000000000013d0 T _ZN6libfoo4foo2Ev
</span></span><span class=line><span class=cl><span class=m>0000000000001450</span> T _ZN6libfoo8internal12foo_internalB5cxx11Ev
</span></span><span class=line><span class=cl>                 U _ZNKSt5ctypeIcE13_M_widen_initEv@GLIBCXX_3.4.11
</span></span><span class=line><span class=cl><span class=m>0000000000001440</span> W _ZNKSt5ctypeIcE8do_widenEc
</span></span><span class=line><span class=cl>                 U _ZNSo3putEc@GLIBCXX_3.4
</span></span><span class=line><span class=cl>                 U _ZNSo5flushEv@GLIBCXX_3.4
</span></span><span class=line><span class=cl>...
</span></span></code></pre></div><p>Looking at this list, there are 2 observations that raise questions:</p><ol><li>this list contains &ldquo;ugly&rdquo; names instead of pretty C++ names. This is called
<a href=https://en.wikipedia.org/wiki/Name_mangling>name mangling</a> and compilers do this to C++ symbols
to make them unique. We can add <code>--demangle</code> parameter to <code>nm</code> to get pretty symbols back:<div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>$ nm --dynamic --demangle libfoo.so  <span class=c1># or &#34;nm -DC&#34;</span>
</span></span><span class=line><span class=cl>...
</span></span><span class=line><span class=cl>                 w _ITM_registerTMCloneTable
</span></span><span class=line><span class=cl>                 U _Unwind_Resume@GCC_3.0
</span></span><span class=line><span class=cl>00000000000012c0 T libfoo::foo<span class=o>()</span>
</span></span><span class=line><span class=cl>00000000000013d0 T libfoo::foo2<span class=o>()</span>
</span></span><span class=line><span class=cl><span class=m>0000000000001450</span> T libfoo::internal::foo_internal<span class=o>[</span>abi:cxx11<span class=o>]()</span>
</span></span><span class=line><span class=cl>                 U std::ctype&lt;char&gt;::_M_widen_init<span class=o>()</span> const@GLIBCXX_3.4.11
</span></span><span class=line><span class=cl><span class=m>0000000000001440</span> W std::ctype&lt;char&gt;::do_widen<span class=o>(</span>char<span class=o>)</span> const
</span></span><span class=line><span class=cl>                 U std::ostream::put<span class=o>(</span>char<span class=o>)</span>@GLIBCXX_3.4
</span></span><span class=line><span class=cl>                 U std::ostream::flush<span class=o>()</span>@GLIBCXX_3.4
</span></span><span class=line><span class=cl>...
</span></span></code></pre></div>Another option is <code>c++filt</code> <a href=https://man7.org/linux/man-pages/man1/c++filt.1.html>tool</a>
from <code>binutils</code>: <code>nm --dynamic libfoo.so | c++filt</code> will give similar output.</li><li>there are way too many symbols in the list including our internal symbols
(<code>libfoo::internal::foo_internal</code>)
and symbols from library dependencies (<code>std::ostream::flush()</code>). This happens because
by default all statically linked symbols are visible and exported from dynamic libraries.
Users of the library can try to use these symbols which is undesirable.
We need to limit symbols visibility to keep the public library API clean.</li></ol><p>Let&rsquo;s <a href=https://man7.org/linux/man-pages/man1/nm.1.html#DESCRIPTION>inspect</a> <code>nm</code> output in more details.
Symbols with address in the first column are &ldquo;real&rdquo; symbols exported from the library.
Users that link against our library can use these symbols (call the functions) freely.
The second column is the <em>type</em> of the symbol. What&rsquo;s important for now:</p><ul><li><code>U</code> means &ldquo;undefined symbol&rdquo; - the symbol is required, and must be provided at runtime via
dependencies (note <code>@GLIBCXX_3.4</code> suffix for example).</li><li><code>T</code> means <em>global</em> symbol &ldquo;in .text section&rdquo; - exported from the library.</li><li><code>t</code> also means a symbol &ldquo;in .text section&rdquo;, but it&rsquo;s <em>local</em> and not exported
(<code>nm --dynamic</code> doesn&rsquo;t show them).</li><li><code>w</code>/<code>W</code> means &ldquo;weak symbol&rdquo;.
When linking the final application, the linker will pick a non-weak symbol over weak symbols,
and pick any weak symbol if no non-weak symbols exist. Typically, weak symbols are
default constructors/destructors and templates instantiations.
They don&rsquo;t violate <a href=https://en.wikipedia.org/wiki/One_Definition_Rule>ODR rule</a>,
and the linker will eliminate duplicates.</li></ul><p>Our goal is to have all symbols forming public API of our library to be exported (in dynamic section),
and no other internal symbols should be exported.</p><h3 id=pass-version-script-file-to-linker>Pass &ldquo;version script&rdquo; file to linker<a hidden class=anchor aria-hidden=true href=#pass-version-script-file-to-linker>#</a></h3><p>Widely used linkers (like GNU <code>ld</code> and <code>gold</code> or LLVM <code>lld</code>) support
<a href=https://man7.org/conf/lca2006/shared_libraries/slide18c.html><em>version script</em> files</a>
via <code>--version-script</code> parameter. Version script files can be used to define visibility of symbols.
An example of such file to export symbols from <code>libfoo::</code> namespace only can look like this:</p><pre tabindex=0><code>{
    global:
        _ZN6libfoo*;
    local:
        *;
};
</code></pre><p>This file uses <em>mangled</em> symbol names, so we need know them upfront (by running <code>nm</code> for example).</p><p>To pass a version script file to the linker we need to add <code>-Wl,--version-script=FILENAME</code> linker option
(or add this flag to <code>LINK_FLAGS</code> <a href=https://cmake.org/cmake/help/latest/prop_tgt/LINK_FLAGS.html>property</a>
of the cmake target).
Let&rsquo;s build the library and inspect exported symbols:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl><span class=c1># `LIBFOO_USE_VERSION_SCRIPT` is a custom option in the example project</span>
</span></span><span class=line><span class=cl>cmake -DCMAKE_BUILD_TYPE<span class=o>=</span>Release -DBUILD_SHARED_LIBS<span class=o>=</span>ON -DLIBFOO_USE_VERSION_SCRIPT<span class=o>=</span>ON ..
</span></span><span class=line><span class=cl>cmake --build .
</span></span><span class=line><span class=cl>ctest
</span></span><span class=line><span class=cl>nm --dynamic --demangle libfoo.so
</span></span><span class=line><span class=cl>...
</span></span><span class=line><span class=cl>                 U _Unwind_Resume@GCC_3.0
</span></span><span class=line><span class=cl>00000000000012c0 T libfoo::foo<span class=o>()</span>
</span></span><span class=line><span class=cl>00000000000013d0 T libfoo::foo2<span class=o>()</span>
</span></span><span class=line><span class=cl><span class=m>0000000000001450</span> T libfoo::internal::foo_internal<span class=o>[</span>abi:cxx11<span class=o>]()</span>
</span></span><span class=line><span class=cl>                 U std::ctype&lt;char&gt;::_M_widen_init<span class=o>()</span> const@GLIBCXX_3.4.11
</span></span><span class=line><span class=cl>...
</span></span></code></pre></div><p>We see that only symbols from <code>libfoo::</code> namespace(s) are exported. But internal symbols
from <code>libfoo::internal::</code> namespace are also exported, which we want to avoid.</p><p>And here comes the problem: it&rsquo;s not possible to refine the filter by adding <code>libfoo::internal::*</code>
in the <code>local</code> section:</p><pre tabindex=0><code>{
    global:
        _ZN6libfoo*;
    local:
        _ZN6libfoo8internal*;  # won&#39;t work :(
        *;
};
</code></pre><p>If a symbol matches any wild-star pattern in <code>global</code> section, this symbol
<a href=https://maskray.me/blog/2020-11-26-all-about-symbol-versioning#version-script>will not be checked</a>
against patterns in <code>local</code> section.</p><p>One potential way to overcome this limitation is to list all symbols we want to export explicitly,
but that&rsquo;s a tedious work. A script to fetch symbols from <code>nm</code> output can be handy,
but requires additional effort.</p><p><strong>Pros</strong>: no code changes required. Configuration lives in a separate file
which can be dynamically created or adjusted.</p><p><strong>Cons</strong>: limitation for visibility of nested namespaces.</p><h3 id=explicitly-annotate-exported-symbols>Explicitly annotate exported symbols<a hidden class=anchor aria-hidden=true href=#explicitly-annotate-exported-symbols>#</a></h3><p>A better way is to tell linker to hide all symbols by default and explicitly annotate symbols
we want to export. Use <code>-fvisibility=hidden</code> linker flag (or set <code>CXX_VISIBILITY_PRESET hidden</code>
<a href=https://cmake.org/cmake/help/latest/prop_tgt/LANG_VISIBILITY_PRESET.html>cmake property</a>) to make
all symbols hidden by default.</p><p><code>__attribute__((visibility("default")))</code> annotation
(for <a href=https://gcc.gnu.org/onlinedocs/gcc/Common-Function-Attributes.html#index-visibility-function-attribute>GCC</a>
and <a href=https://clang.llvm.org/docs/LTOVisibility.html>clang</a>)
marks symbols for exporting. We can define a macro to avoid typing it every time:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=cp>#define PUBLIC_API_FOO __attribute__((visibility(&#34;default&#34;)))
</span></span></span><span class=line><span class=cl><span class=cp></span><span class=n>PUBLIC_API_FOO</span> <span class=kt>void</span> <span class=nf>foo</span><span class=p>();</span>
</span></span></code></pre></div><p>It&rsquo;s a common practice to annotate symbols in public header files, but these headers are also
usually shipped to customers, and customers don&rsquo;t need this annotation in their code.
This macro needs to be defined to nothing when used outside of our build system.
<code>cmake</code> automatically provides <code>&lt;target>_EXPORTS</code>
<a href=https://cmake.org/cmake/help/latest/prop_tgt/DEFINE_SYMBOL.html>compiler definition</a>
when a library is built as shared, so we can use it:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=cp>#ifdef foo_EXPORTS
</span></span></span><span class=line><span class=cl><span class=cp>#  define PUBLIC_API_FOO __attribute__((visibility(&#34;default&#34;)))
</span></span></span><span class=line><span class=cl><span class=cp>#else
</span></span></span><span class=line><span class=cl><span class=cp>#  define PUBLIC_API_FOO
</span></span></span><span class=line><span class=cl><span class=cp>#endif
</span></span></span><span class=line><span class=cl><span class=cp></span><span class=n>PUBLIC_API_FOO</span> <span class=kt>void</span> <span class=nf>foo</span><span class=p>();</span>
</span></span></code></pre></div><p>If we now build the library and inspect exported symbols:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl><span class=c1># `LIBFOO_API_VISIBILITY` is a custom option in the example project</span>
</span></span><span class=line><span class=cl>cmake -DCMAKE_BUILD_TYPE<span class=o>=</span>Release -DBUILD_SHARED_LIBS<span class=o>=</span>ON -DLIBFOO_API_VISIBILITY<span class=o>=</span>ON ..
</span></span><span class=line><span class=cl>cmake --build .
</span></span><span class=line><span class=cl>ctest
</span></span><span class=line><span class=cl>nm --dynamic --demangle libfoo.so
</span></span><span class=line><span class=cl>...
</span></span><span class=line><span class=cl>                 U _Unwind_Resume@GCC_3.0
</span></span><span class=line><span class=cl>00000000000012a0 T libfoo::foo<span class=o>()</span>
</span></span><span class=line><span class=cl>                 U std::ctype&lt;char&gt;::_M_widen_init<span class=o>()</span> const@GLIBCXX_3.4.11
</span></span><span class=line><span class=cl>...
</span></span></code></pre></div><p>we&rsquo;ll see that only annotated symbols are exported.</p><p><strong>Note</strong>: Don&rsquo;t forget to <code>#include</code> public headers that define exported symbols
into compilable files (cpp/cxx/cc).
If a header file is never included in any translation unit, it&rsquo;s not processed and effectively ignored.</p><p><strong>Pros</strong>: all exported symbols are explicitly annotated. It&rsquo;s a conscious decision and low risk of mistakes.</p><p><strong>Cons</strong>:</p><ul><li>public headers are &ldquo;polluted&rdquo; with <code>PUBLIC_API_FOO</code> macro, which is meaningless for clients;</li><li>if different clients need to have access to different set of symbols,
this approach requires bulky fine-tuning (for example, split API into categories and export
different categories for different customers);</li></ul><h3 id=exported-symbols-and-testing>Exported symbols and testing<a hidden class=anchor aria-hidden=true href=#exported-symbols-and-testing>#</a></h3><p>Hidden symbols are not visible for the users of the library. Tests (unit tests, components test, etc) are
also users of the library, they cannot access hidden symbols.</p><p>Shared libraries need well-written interface tests to verify the produced binary.
The rest of the testing can be performed on a dedicated build that doesn&rsquo;t hide symbols.</p><h2 id=dependencies>Dependencies<a hidden class=anchor aria-hidden=true href=#dependencies>#</a></h2><p>Shared libraries as any other binaries may have dependencies on other shared libraries.
<code>readelf</code> <a href=https://www.man7.org/linux/man-pages/man1/readelf.1.html>tool</a> can show what dependencies
our library has. Let&rsquo;s build <code>libfoo</code>:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>cmake -DCMAKE_BUILD_TYPE<span class=o>=</span>Release -DBUILD_SHARED_LIBS<span class=o>=</span>ON ..
</span></span><span class=line><span class=cl>cmake --build .  <span class=c1># build succeeds</span>
</span></span></code></pre></div><p>and inspect the produced library:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>$ readelf --dynamic libfoo.so
</span></span><span class=line><span class=cl>  Tag        Type                         Name/Value
</span></span><span class=line><span class=cl> 0x0000000000000001 <span class=o>(</span>NEEDED<span class=o>)</span>             Shared library: <span class=o>[</span>libstdc++.so.6<span class=o>]</span>
</span></span><span class=line><span class=cl> 0x0000000000000001 <span class=o>(</span>NEEDED<span class=o>)</span>             Shared library: <span class=o>[</span>libgcc_s.so.1<span class=o>]</span>
</span></span><span class=line><span class=cl> 0x0000000000000001 <span class=o>(</span>NEEDED<span class=o>)</span>             Shared library: <span class=o>[</span>libc.so.6<span class=o>]</span>
</span></span><span class=line><span class=cl> 0x000000000000000e <span class=o>(</span>SONAME<span class=o>)</span>             Library soname: <span class=o>[</span>libfoo.so<span class=o>]</span>
</span></span><span class=line><span class=cl>...
</span></span></code></pre></div><p><code>NEEDED</code> records are shared libraries that our library depends on.</p><p>Alternatively we can use <code>ldd</code> <a href=https://man7.org/linux/man-pages/man1/ldd.1.html>tool</a>
to print all (including transitive) shared dependencies.
<code>ldd</code> is a runtime tool: it actually invokes the dynamic linker to find dependencies,
so it might not always work (for example if the library is cross-compiled for another architecture).</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>$ ldd libfoo.so
</span></span><span class=line><span class=cl>        linux-vdso.so.1 <span class=o>(</span>0x00007ffc04386000<span class=o>)</span>
</span></span><span class=line><span class=cl>        libstdc++.so.6 <span class=o>=</span>&gt; /lib/x86_64-linux-gnu/libstdc++.so.6 <span class=o>(</span>0x00007734bbc00000<span class=o>)</span>
</span></span><span class=line><span class=cl>        libgcc_s.so.1 <span class=o>=</span>&gt; /lib/x86_64-linux-gnu/libgcc_s.so.1 <span class=o>(</span>0x00007734bbe9e000<span class=o>)</span>
</span></span><span class=line><span class=cl>        libc.so.6 <span class=o>=</span>&gt; /lib/x86_64-linux-gnu/libc.so.6 <span class=o>(</span>0x00007734bb800000<span class=o>)</span>
</span></span><span class=line><span class=cl>        libm.so.6 <span class=o>=</span>&gt; /lib/x86_64-linux-gnu/libm.so.6 <span class=o>(</span>0x00007734bbb19000<span class=o>)</span>
</span></span><span class=line><span class=cl>        /lib64/ld-linux-x86-64.so.2 <span class=o>(</span>0x00007734bbeca000<span class=o>)</span>
</span></span></code></pre></div><p>If our library depends on another <em>our</em> library, we have to ship this dependency along with the library itself.
A better way is <em>statically</em> link dependencies into the final shared library,
that will simplify management a lot, but in some cases it&rsquo;s not possible or allowed.</p><p><strong>Note</strong>: I&rsquo;m talking about <em>first-party</em> dependencies (dependencies that we as developers produce).
<em>System</em> dependencies should not be statically linked or packaged with the deliverables.
<em>Third-party</em> dependencies (like <code>openssl</code>) can follow both approaches and they should be handled on
case-by-case basis.</p><p>When <code>cmake --build</code> produces a library it embeds full paths to dependencies as <code>RUNPATH</code> records:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>readelf --dynamic ...so
</span></span><span class=line><span class=cl>...
</span></span><span class=line><span class=cl> 0x0000000000000001 <span class=o>(</span>NEEDED<span class=o>)</span>             Shared library: <span class=o>[</span>libbar.so<span class=o>]</span>
</span></span><span class=line><span class=cl> 0x000000000000001d <span class=o>(</span>RUNPATH<span class=o>)</span>            Library runpath: <span class=o>[</span>/home/andrey/projects/learning-playground/linux-shared-lib/build/libbar:<span class=o>]</span>
</span></span><span class=line><span class=cl>...
</span></span></code></pre></div><p>which allows any executable in the project (tests or apps) to run without additional configuration,
but that&rsquo;s not portable.
<code>cmake --install</code> strips these records and leaves just <code>NEEDED</code> record for each dependency:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>readelf --dynamic installed/...so
</span></span><span class=line><span class=cl>...
</span></span><span class=line><span class=cl> 0x0000000000000001 <span class=o>(</span>NEEDED<span class=o>)</span>             Shared library: <span class=o>[</span>libbar.so<span class=o>]</span>
</span></span></code></pre></div><p>This moves the responsibility to provide runtime search paths to the final application.
The clients application may be shipped along with its dependencies,
or can be an application that expects dependencies to be in specific locations within
the application bundle (like Android APK for example).
In such cases better let the client deal with search paths.</p><p><strong>Note</strong>: there&rsquo;s a very good talk
<a href="https://www.youtube.com/watch?v=Ik3gR65oVsM">&ldquo;C++ Shared Libraries and Where To Find Them&rdquo;</a>
that explains <code>RPATH</code>/<code>RUNPATH</code> handling at compile time and runtime.</p><h2 id=abi-versioning-via-soname>ABI versioning via SONAME<a hidden class=anchor aria-hidden=true href=#abi-versioning-via-soname>#</a></h2><p><code>readelf --dynamic</code> shows <code>SONAME</code> record, which contains a value similar to the filename of the shared library.
This value will be embedded into the client application as dynamic dependency when the app is linked
against our library. Even though the app links against <code>libfoo.so</code> during the build,
at runtime the app will look for a file with the name taken from <code>SONAME</code> record of <code>libfoo.so</code>.</p><p>This mechanism allows updates of libraries without rebuilding client applications.
Libraries that use ABI version management are usually shipped with symlinks, for example:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>libfoo.so -&gt; libfoo.so.1  <span class=c1># symlink</span>
</span></span><span class=line><span class=cl>libfoo.so.1 -&gt; libfoo.so.1.0.0  <span class=c1># symlink</span>
</span></span><span class=line><span class=cl>libfoo.so.1.0.0  <span class=c1># actual library file</span>
</span></span></code></pre></div><p>and <code>SONAME</code> record of the library contains <code>libfoo.so.1</code>.
When an app is linked against <code>libfoo.so</code>, at runtime this app will look for <code>libfoo.so.1</code> file
(value of <code>SONAME</code> record). This allows users to update <code>libfoo</code> to version <code>1.0.1</code> or <code>1.1.0</code>
and the app will continue to work (as long as the update process updates symlinks:
<code>libfoo.so.1 -> libfoo.so.1.1.0</code>).
Users can even install multiple major versions of the same library (<code>1.1.0</code> and <code>2.0.0</code>) and
apps will be able to find the correct dependency at runtime
(one app that depends on <code>libfoo.so.1</code> will pick <code>libfoo.so.1.1.0</code> while another app
that depends on <code>libfoo.so.2</code> will pick <code>libfoo.so.2.0.0</code>).</p><p><strong>Note</strong>: it&rsquo;s the responsibility of the library authors to <em>actually</em> maintain ABI compatibility.</p><p>In <code>cmake</code> this can be configured via <code>VERSION</code> and <code>SOVERSION</code> <a href=https://cmake.org/cmake/help/latest/prop_tgt/SOVERSION.html>properties</a>.
Let&rsquo;s build <code>libfoo</code>:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl><span class=c1># `LIBFOO_VERSIONING` is a custom option in the example project</span>
</span></span><span class=line><span class=cl>cmake -DCMAKE_BUILD_TYPE<span class=o>=</span>RelWithDebInfo -DBUILD_SHARED_LIBS<span class=o>=</span>ON -DLIBFOO_VERSIONING<span class=o>=</span>ON ..
</span></span><span class=line><span class=cl>cmake --build .
</span></span></code></pre></div><p>and inspect the produced files:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>$ ls -la *.so*
</span></span><span class=line><span class=cl>lrwxrwxrwx <span class=m>1</span> user user     <span class=m>11</span> Sep  <span class=m>2</span> 19:56 libfoo.so -&gt; libfoo.so.1*
</span></span><span class=line><span class=cl>lrwxrwxrwx <span class=m>1</span> user user     <span class=m>15</span> Sep  <span class=m>2</span> 19:56 libfoo.so.1 -&gt; libfoo.so.1.2.3*
</span></span><span class=line><span class=cl>-rwxr-xr-x <span class=m>1</span> user user <span class=m>106840</span> Sep  <span class=m>2</span> 19:56 libfoo.so.1.2.3*
</span></span><span class=line><span class=cl>$ readelf --dynamic libfoo.so <span class=p>|</span> grep SONAME
</span></span><span class=line><span class=cl> 0x000000000000000e <span class=o>(</span>SONAME<span class=o>)</span>             Library soname: <span class=o>[</span>libfoo.so.1<span class=o>]</span>
</span></span></code></pre></div><p>If an app is linked against <code>libfoo.so</code>, it will depend at runtime on <code>libfoo.so.1</code>:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>$ readelf --dynamic ./app
</span></span><span class=line><span class=cl>...
</span></span><span class=line><span class=cl> 0x0000000000000001 <span class=o>(</span>NEEDED<span class=o>)</span>             Shared library: <span class=o>[</span>libfoo.so.1<span class=o>]</span>
</span></span><span class=line><span class=cl>...
</span></span></code></pre></div><p>This might be useful if the shared library that we deliver may be updated on-the-fly,
and client apps must continue to work.
If the client app is used as a single package and library updates can&rsquo;t happen
(for example if our library is packaged in an Android APK file),
this versioning can be safely ignored.</p><h2 id=usage>Usage<a hidden class=anchor aria-hidden=true href=#usage>#</a></h2><p>When clients want to use our library, they need to link against <code>libfoo.so</code> and
add the path to public headers of our library to their include path.</p><p><code>cmake</code> has a concept of <a href=https://cmake.org/cmake/help/latest/command/add_library.html#imported-libraries>imported targets</a> for this purpose:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cmake data-lang=cmake><span class=line><span class=cl><span class=nb>add_library</span><span class=p>(</span><span class=s>foo</span> <span class=s>SHARED</span> <span class=s>IMPORTED</span><span class=p>)</span><span class=err>
</span></span></span><span class=line><span class=cl><span class=err></span><span class=nb>set_target_properties</span><span class=p>(</span><span class=s>foo</span> <span class=s>PROPERTIES</span>
</span></span><span class=line><span class=cl>    <span class=s>IMPORTED_LOCATION</span> <span class=s>path/to/libfoo.so</span>
</span></span><span class=line><span class=cl>    <span class=s>IMPORTED_SONAME</span> <span class=s>libfoo.so</span>
</span></span><span class=line><span class=cl><span class=p>)</span><span class=err>
</span></span></span><span class=line><span class=cl><span class=err></span><span class=nb>target_include_directories</span><span class=p>(</span><span class=s>foo</span> <span class=s>INTERFACE</span> <span class=s>path/to/libfoo/headers</span><span class=p>)</span><span class=err>
</span></span></span></code></pre></div><p><code>IMPORTED_SONAME</code> <a href=https://cmake.org/cmake/help/latest/prop_tgt/IMPORTED_SONAME.html>property</a>
must match <code>SONAME</code> record in <code>libfoo.so</code>.
After that <code>foo</code> target can be used as any other target:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cmake data-lang=cmake><span class=line><span class=cl><span class=nb>target_link_libraries</span><span class=p>(</span><span class=s>app</span> <span class=s>PRIVATE</span> <span class=s>foo</span><span class=p>)</span><span class=err>
</span></span></span></code></pre></div><p>Let&rsquo;s build and install <code>libfoo</code>:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl><span class=nb>cd</span> libfoo/build
</span></span><span class=line><span class=cl>cmake -DCMAKE_BUILD_TYPE<span class=o>=</span>Release -DBUILD_SHARED_LIBS<span class=o>=</span>ON -DLIBFOO_API_VISIBILITY<span class=o>=</span>ON -DLIBFOO_STRIP<span class=o>=</span>ON ..
</span></span><span class=line><span class=cl>cmake --build .  <span class=c1># build succeeds</span>
</span></span><span class=line><span class=cl>ctest  <span class=c1># tests run and pass - the library is usable</span>
</span></span><span class=line><span class=cl>cmake --install . --prefix<span class=o>=</span>../out --strip  <span class=c1># install libfoo into &#39;libfoo/out&#39;</span>
</span></span></code></pre></div><p>build the app:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl><span class=nb>cd</span> app/build
</span></span><span class=line><span class=cl><span class=c1># `LIBFOO_BASE_DIR` is a custom option in the example project</span>
</span></span><span class=line><span class=cl>cmake -DCMAKE_BUILD_TYPE<span class=o>=</span>Release -DLIBFOO_BASE_DIR<span class=o>=</span>../libfoo/out ..
</span></span><span class=line><span class=cl>cmake --build .
</span></span><span class=line><span class=cl>./app  <span class=c1># runs and prints output</span>
</span></span></code></pre></div><p>and inspect the executable:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>$ readelf --dynamic app
</span></span><span class=line><span class=cl>...
</span></span><span class=line><span class=cl> 0x0000000000000001 <span class=o>(</span>NEEDED<span class=o>)</span>             Shared library: <span class=o>[</span>libfoo.so<span class=o>]</span>
</span></span><span class=line><span class=cl> 0x000000000000001d <span class=o>(</span>RUNPATH<span class=o>)</span>            Library runpath: <span class=o>[</span>/home/andrey/projects/learning-playground/linux-shared-lib/libfoo/out/lib:<span class=o>]</span>
</span></span><span class=line><span class=cl>...
</span></span><span class=line><span class=cl>$ ldd app
</span></span><span class=line><span class=cl>        linux-vdso.so.1 <span class=o>(</span>0x00007ffe6416f000<span class=o>)</span>
</span></span><span class=line><span class=cl>        libfoo.so <span class=o>=</span>&gt; /home/andrey/projects/learning-playground/linux-shared-lib/libfoo/out/lib/libfoo.so <span class=o>(</span>0x0000771d1f915000<span class=o>)</span>
</span></span><span class=line><span class=cl>...
</span></span></code></pre></div><p>This is the executable in the <code>cmake</code> <em>build tree</em>, it contains <code>RUNPATH</code> to locate the exact library
it was linked with.</p><p>To make this application portable, it needs to be installed via <code>cmake --install</code>:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>cmake --install . --prefix<span class=o>=</span>../out --strip
</span></span><span class=line><span class=cl>readelf --dynamic ../out/bin/app
</span></span><span class=line><span class=cl>...
</span></span><span class=line><span class=cl> 0x0000000000000001 <span class=o>(</span>NEEDED<span class=o>)</span>             Shared library: <span class=o>[</span>libfoo.so<span class=o>]</span>
</span></span><span class=line><span class=cl> 0x0000000000000001 <span class=o>(</span>NEEDED<span class=o>)</span>             Shared library: <span class=o>[</span>libstdc++.so.6<span class=o>]</span>
</span></span><span class=line><span class=cl> 0x0000000000000001 <span class=o>(</span>NEEDED<span class=o>)</span>             Shared library: <span class=o>[</span>libc.so.6<span class=o>]</span>
</span></span><span class=line><span class=cl>...
</span></span></code></pre></div><p>It has no <code>RPATH</code>/<code>RUNPATH</code> records by default. If we try to run the app, it will fail:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>$ ../out/bin/app
</span></span><span class=line><span class=cl>../out/bin/app: error <span class=k>while</span> loading shared libraries: libfoo.so: cannot open shared object file: No such file or directory
</span></span></code></pre></div><p>And that&rsquo;s expected, because <code>libfoo.so</code> is not in any standard search path of the system.
We need to either explicitly set relative <code>RPATH</code> for the application during the build and
put our libraries there,
or use <code>LD_LIBRARY_PATH</code> <a href=https://man7.org/linux/man-pages/man8/ld.so.8.html>environment variable</a>:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>linux-shared-lib$ <span class=nv>LD_LIBRARY_PATH</span><span class=o>=</span>libfoo/out/lib/ ./app/out/bin/app
</span></span><span class=line><span class=cl>Hello world!
</span></span></code></pre></div><p>cmake project for the client application can be configured to also copy shared libraries
from dependencies, copy debug info files, and more, but that&rsquo;s out of scope for this page.</p><h2 id=references>References<a hidden class=anchor aria-hidden=true href=#references>#</a></h2><ul><li><a href=https://stackoverflow.com/a/59314670/10286966>StackOverflow: What are CMAKE_BUILD_TYPE: Debug, Release, RelWithDebInfo and MinSizeRel?</a></li><li><a href=https://www.gnu.org/software/gnulib/manual/html_node/Exported-Symbols-of-Shared-Libraries.html>Controlling the Exported Symbols of Shared Libraries</a></li><li><a href=https://en.wikipedia.org/wiki/Strip_(Unix)>Stripped binaries (wiki)</a></li><li><a href="https://www.youtube.com/watch?v=Ik3gR65oVsM"><span class=inline-icon><svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M22.54 6.42a2.78 2.78.0 00-1.94-2C18.88 4 12 4 12 4s-6.88.0-8.6.46a2.78 2.78.0 00-1.94 2A29 29 0 001 11.75a29 29 0 00.46 5.33A2.78 2.78.0 003.4 19c1.72.46 8.6.46 8.6.46s6.88.0 8.6-.46a2.78 2.78.0 001.94-2 29 29 0 00.46-5.25 29 29 0 00-.46-5.33z"/><polygon points="9.75 15.02 15.5 11.75 9.75 8.48 9.75 15.02"/></svg>
</span>C++ Shared Libraries and Where To Find Them</a></li><li><a href=https://gcc.gnu.org/wiki/Visibility>GNU Wiki: Visibility attribute</a></li></ul></div><footer class=post-footer><ul class=post-tags><li><a href=https://andreynautilus.github.io/tags/c++/>C++</a></li><li><a href=https://andreynautilus.github.io/tags/shared-library/>shared library</a></li><li><a href=https://andreynautilus.github.io/tags/cmake/>cmake</a></li></ul><nav class=paginav><a class=prev href=https://andreynautilus.github.io/posts/2025-09-06-yaml-anchors-multiline-text/><span class=title>« Prev</span><br><span>YAML: anchors and multiline text</span>
</a><a class=next href=https://andreynautilus.github.io/posts/2025-08-23-git-blame-ignore/><span class=title>Next »</span><br><span>Keep 'git blame' clean</span></a></nav></footer></article></main><footer class=footer><span>&copy; 2025 <a href=https://andreynautilus.github.io/>Andrey Nautilus blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>
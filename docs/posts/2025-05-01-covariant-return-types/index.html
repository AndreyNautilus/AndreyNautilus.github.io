<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Covariant types in C++ virtual methods | Andrey Nautilus blog</title><meta name=keywords content="C++"><meta name=description content="Return types of methods-overrides may be different"><meta name=author content><link rel=canonical href=https://andreynautilus.github.io/posts/2025-05-01-covariant-return-types/><link crossorigin=anonymous href=/assets/css/stylesheet.8fe10233a706bc87f2e08b3cf97b8bd4c0a80f10675a143675d59212121037c0.css integrity="sha256-j+ECM6cGvIfy4Is8+XuL1MCoDxBnWhQ2ddWSEhIQN8A=" rel="preload stylesheet" as=style><link rel=icon href=https://andreynautilus.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://andreynautilus.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://andreynautilus.github.io/favicon-32x32.png><link rel=apple-touch-icon href=https://andreynautilus.github.io/apple-touch-icon.png><link rel=mask-icon href=https://andreynautilus.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://andreynautilus.github.io/posts/2025-05-01-covariant-return-types/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script type=text/javascript>(function(e,t,n,s,o,i,a){e[o]=e[o]||function(){(e[o].a=e[o].a||[]).push(arguments)},e[o].l=1*new Date;for(var r=0;r<document.scripts.length;r++)if(document.scripts[r].src===s)return;i=t.createElement(n),a=t.getElementsByTagName(n)[0],i.async=1,i.src=s,a.parentNode.insertBefore(i,a)})(window,document,"script","https://mc.yandex.ru/metrika/tag.js","ym"),ym(99367858,"init",{clickmap:!0,trackLinks:!0,accurateTrackBounce:!0})</script><noscript><div><img src=https://mc.yandex.ru/watch/99367858 style=position:absolute;left:-9999px alt></div></noscript><script async src="https://www.googletagmanager.com/gtag/js?id=G-S584PB390B"></script><script>window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-S584PB390B")</script><link rel=stylesheet href=/css/global/card_tags.min.08b084a05dddb2ae47b67783718d65c42eecc00cfee8c93fc63800741d66cc86.css integrity="sha256-CLCEoF3dsq5HtneDcY1lxC7swAz+6Mk/xjgAdB1mzIY=" as=style><link rel=stylesheet href=/css/global/builtin_icon.min.af7971272ac3da29f13218095878a0d6404d665d4c1192b7bfc4cc894d4eb76a.css integrity="sha256-r3lxJyrD2inxMhgJWHig1kBNZl1MEZK3v8TMiU1Ot2o=" as=style><meta property="og:url" content="https://andreynautilus.github.io/posts/2025-05-01-covariant-return-types/"><meta property="og:site_name" content="Andrey Nautilus blog"><meta property="og:title" content="Covariant types in C++ virtual methods"><meta property="og:description" content="Return types of methods-overrides may be different"><meta property="og:locale" content="en"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2025-05-01T22:47:08+02:00"><meta property="article:modified_time" content="2025-05-01T22:47:08+02:00"><meta property="article:tag" content="C++"><meta name=twitter:card content="summary"><meta name=twitter:title content="Covariant types in C++ virtual methods"><meta name=twitter:description content="Return types of methods-overrides may be different"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"posts","item":"https://andreynautilus.github.io/posts/"},{"@type":"ListItem","position":2,"name":"Covariant types in C++ virtual methods","item":"https://andreynautilus.github.io/posts/2025-05-01-covariant-return-types/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Covariant types in C++ virtual methods","name":"Covariant types in C\u002b\u002b virtual methods","description":"Return types of methods-overrides may be different","keywords":["C++"],"articleBody":"Many years ago I saw a code like this and was quite pizzled: Derived::bar overrides Base::bar even though the return types are different.\nclass A { public: virtual void hello() const { std::cout \u003c\u003c \"Hello from A\" \u003c\u003c std::endl; } }; class B: public A { public: void hello() const override { std::cout \u003c\u003c \"Hello from B\" \u003c\u003c std::endl; } }; class Base { public: virtual A* bar() { return \u0026a; } private: A a; }; class Derived: public Base { public: // return type is different B* bar() override { return \u0026b; } private: B b; }; (see the code on Compiler Explorer)\nWell, according to C++ standard it’s absolutely valid and in line with the definition of virtual methods\nIf some member function vf is declared as virtual in a class Base, and some class Derived, which is derived, directly or indirectly, from Base, has a declaration for member function with the same\nname parameter type list (but not the return type) cv-qualifiers ref-qualifiers Then this function in the class Derived is also virtual (whether or not the keyword virtual is used in its declaration) and overrides Base::vf (whether or not the specifier override is used in its declaration). The most interesting part is that the return type doesn’t have to be the same.\nCovariant types This trick is called Covariant return types:\nIf the function Derived::f overrides a function Base::f, their return types must either be the same or be covariant. Two types are covariant if they satisfy all of the following requirements:\nboth types are pointers or references (lvalue or rvalue) to classes. Multi-level pointers or references are not allowed. the referenced/pointed-to class in the return type of Base::f() must be an unambiguous and accessible direct or indirect base class of the referenced/pointed-to class of the return type of Derived::f(). the return type of Derived::f() must be equally or less cv-qualified than the return type of Base::f(). In the example above both A* and B* are pointers, A is a base class of B, and A* and B* have the same cv-qualifiers. So, they’re coveriant types, and Derived::bar overrides virtual Base::bar method.\nEven more, Base::bar may change the return type to const A*, and everything will continue to work (because B* is less cv-qualified than const A*).\nclass Base { public: virtual const A* bar() { return \u0026a; } private: A a; }; class Derived: public Base { public: // return type is different B* bar() override { return \u0026b; } private: B b; }; Notes I haven’t seen this trick in production code since then, so its usefulness is questionable.\nPotentially, it can be used to get the implementation of the interface from the interface itself in places where the implementation class is accessible.\n","wordCount":"459","inLanguage":"en","datePublished":"2025-05-01T22:47:08+02:00","dateModified":"2025-05-01T22:47:08+02:00","mainEntityOfPage":{"@type":"WebPage","@id":"https://andreynautilus.github.io/posts/2025-05-01-covariant-return-types/"},"publisher":{"@type":"Organization","name":"Andrey Nautilus blog","logo":{"@type":"ImageObject","url":"https://andreynautilus.github.io/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://andreynautilus.github.io/ accesskey=h title="Andrey Nautilus blog (Alt + H)"><img src=https://andreynautilus.github.io/apple-touch-icon.png alt aria-label=logo height=35>Andrey Nautilus blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://andreynautilus.github.io/links/ title=links><span>links</span></a></li><li><a href=https://andreynautilus.github.io/tags/ title=tags><span>tags</span></a></li><li><a href=https://andreynautilus.github.io/search/ title="search (Alt + /)" accesskey=/><span>search</span></a></li><li><a href=https://github.com/AndreyNautilus/AndreyNautilus.github.io title=src><span>src</span>&nbsp;
<svg fill="none" shape-rendering="geometricPrecision" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2.5" viewBox="0 0 24 24" height="12" width="12"><path d="M18 13v6a2 2 0 01-2 2H5a2 2 0 01-2-2V8a2 2 0 012-2h6"/><path d="M15 3h6v6"/><path d="M10 14 21 3"/></svg></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://andreynautilus.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://andreynautilus.github.io/posts/>posts</a></div><h1 class="post-title entry-hint-parent">Covariant types in C++ virtual methods</h1><div class=post-meta><span title='2025-05-01 22:47:08 +0200 +0200'>May 1, 2025</span>&nbsp;·&nbsp;3 min</div></header><div class=post-content><p>Many years ago I saw a code like this and was quite pizzled:
<code>Derived::bar</code> overrides <code>Base::bar</code> even though the return types are different.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>class</span> <span class=nc>A</span> <span class=p>{</span>
</span></span><span class=line><span class=cl><span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=k>virtual</span> <span class=kt>void</span> <span class=n>hello</span><span class=p>()</span> <span class=k>const</span> <span class=p>{</span> <span class=n>std</span><span class=o>::</span><span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=s>&#34;Hello from A&#34;</span> <span class=o>&lt;&lt;</span> <span class=n>std</span><span class=o>::</span><span class=n>endl</span><span class=p>;</span> <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>class</span> <span class=nc>B</span><span class=o>:</span> <span class=k>public</span> <span class=n>A</span> <span class=p>{</span>
</span></span><span class=line><span class=cl><span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=kt>void</span> <span class=n>hello</span><span class=p>()</span> <span class=k>const</span> <span class=k>override</span> <span class=p>{</span> <span class=n>std</span><span class=o>::</span><span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=s>&#34;Hello from B&#34;</span> <span class=o>&lt;&lt;</span> <span class=n>std</span><span class=o>::</span><span class=n>endl</span><span class=p>;</span> <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>class</span> <span class=nc>Base</span> <span class=p>{</span>
</span></span><span class=line><span class=cl><span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=k>virtual</span> <span class=n>A</span><span class=o>*</span> <span class=n>bar</span><span class=p>()</span> <span class=p>{</span> <span class=k>return</span> <span class=o>&amp;</span><span class=n>a</span><span class=p>;</span> <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=k>private</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=n>A</span> <span class=n>a</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>class</span> <span class=nc>Derived</span><span class=o>:</span> <span class=k>public</span> <span class=n>Base</span> <span class=p>{</span>
</span></span><span class=line><span class=cl><span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=c1>// return type is different
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>B</span><span class=o>*</span> <span class=n>bar</span><span class=p>()</span> <span class=k>override</span> <span class=p>{</span> <span class=k>return</span> <span class=o>&amp;</span><span class=n>b</span><span class=p>;</span> <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=k>private</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=n>B</span> <span class=n>b</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span></code></pre></div><p>(see <a href="https://godbolt.org/#g:!((g:!((g:!((h:codeEditor,i:(filename:'1',fontScale:14,fontUsePx:'0',j:1,lang:c%2B%2B,selection:(endColumn:12,endLineNumber:16,positionColumn:12,positionLineNumber:16,selectionStartColumn:12,selectionStartLineNumber:16,startColumn:12,startLineNumber:16),source:'%23include+%3Ciostream%3E%0A%23include+%3Cmemory%3E%0A%0Aclass+A+%7B%0Apublic:%0A++++virtual+void+hello()+const+%7B+std::cout+%3C%3C+%22Hello+from+A%22+%3C%3C+std::endl%3B+%7D%0A%7D%3B%0A%0Aclass+B:+public+A+%7B%0Apublic:%0A++++void+hello()+const+override+%7B+std::cout+%3C%3C+%22Hello+from+B%22+%3C%3C+std::endl%3B+%7D%0A%7D%3B%0A%0Aclass+Base+%7B%0Apublic:%0A++++virtual+A*+bar()+%7B+return+%26a%3B+%7D%0Aprivate:%0A++++A+a%3B%0A%7D%3B%0A%0Aclass+Derived:+public+Base+%7B%0Apublic:%0A++++B*+bar()+override+%7B+return+%26b%3B+%7D%0Aprivate:%0A++++B+b%3B%0A%7D%3B%0A%0A%0Aint+main()+%7B%0A++++Derived+d%7B%7D%3B%0A++++d.bar()-%3Ehello()%3B%0A%0A++++Base+%26b+%3D+d%3B%0A++++b.bar()-%3Ehello()%3B%0A%0A++++return+0%3B%0A%7D'),l:'5',n:'0',o:'C%2B%2B+source+%231',t:'0')),k:46.768507638072855,l:'4',n:'0',o:'',s:0,t:'0'),(g:!((g:!((h:executor,i:(argsPanelShown:'1',compilationPanelShown:'0',compiler:g142,compilerName:'',compilerOutShown:'0',execArgs:'',execStdin:'',fontScale:14,fontUsePx:'0',j:1,lang:c%2B%2B,libs:!(),options:'-std%3Dc%2B%2B17',overrides:!(),runtimeTools:!(),source:1,stdinPanelShown:'1',wrap:'1'),l:'5',n:'0',o:'Executor+x86-64+gcc+14.2+(C%2B%2B,+Editor+%231)',t:'0')),k:100,l:'4',m:45.26795895096921,n:'0',o:'',s:0,t:'0'),(g:!((h:executor,i:(argsPanelShown:'1',compilationPanelShown:'0',compiler:clang1910,compilerName:'',compilerOutShown:'0',execArgs:'',execStdin:'',fontScale:14,fontUsePx:'0',j:2,lang:c%2B%2B,libs:!(),options:'-std%3Dc%2B%2B17',overrides:!(),runtimeTools:!(),source:1,stdinPanelShown:'1',wrap:'1'),l:'5',n:'0',o:'Executor+x86-64+clang+19.1.0+(C%2B%2B,+Editor+%231)',t:'0')),header:(),k:100,l:'4',m:54.73204104903079,n:'0',o:'',s:0,t:'0')),k:53.231492361927145,l:'3',n:'0',o:'',t:'0')),l:'2',n:'0',o:'',t:'0')),version:4">the code on Compiler Explorer</a>)</p><p>Well, according to C++ standard it&rsquo;s absolutely valid and
<a href=https://en.cppreference.com/w/cpp/language/virtual#In_detail>in line with the definition of <em>virtual</em> methods</a></p><blockquote><p>If some member function <em>vf</em> is declared as <code>virtual</code> in a class Base, and some class Derived,
which is derived, directly or indirectly, from Base, has a declaration for member function with the same</p><ul><li>name</li><li>parameter type list (but not the return type)</li><li>cv-qualifiers</li><li>ref-qualifiers</li><li>Then this function in the class Derived is also <em>virtual</em> (whether or not the keyword <code>virtual</code> is used in its declaration) and
overrides Base::vf (whether or not the specifier <code>override</code> is used in its declaration).</li></ul></blockquote><p>The most interesting part is that the return type doesn&rsquo;t have to be the same.</p><h2 id=covariant-types>Covariant types<a hidden class=anchor aria-hidden=true href=#covariant-types>#</a></h2><p>This trick is called <a href=https://en.cppreference.com/w/cpp/language/virtual#Covariant_return_types>Covariant return types</a>:</p><blockquote><p>If the function Derived::f overrides a function Base::f, their return types must either be the same or be <em>covariant</em>.
Two types are <em>covariant</em> if they satisfy all of the following requirements:</p><ul><li>both types are pointers or references (lvalue or rvalue) to classes. Multi-level pointers or references are not allowed.</li><li>the referenced/pointed-to class in the return type of Base::f() must be an unambiguous and
accessible direct or indirect base class of the referenced/pointed-to class of the return type of Derived::f().</li><li>the return type of Derived::f() must be equally or less cv-qualified than the return type of Base::f().</li></ul></blockquote><p>In the example above both <code>A*</code> and <code>B*</code> are pointers, <code>A</code> is a base class of <code>B</code>, and <code>A*</code> and <code>B*</code> have the same cv-qualifiers.
So, they&rsquo;re <em>coveriant</em> types, and <code>Derived::bar</code> overrides virtual <code>Base::bar</code> method.</p><p>Even more, <code>Base::bar</code> may change the return type to <code>const A*</code>, and everything will
<a href="https://godbolt.org/#g:!((g:!((g:!((h:codeEditor,i:(filename:'1',fontScale:14,fontUsePx:'0',j:1,lang:c%2B%2B,selection:(endColumn:1,endLineNumber:28,positionColumn:1,positionLineNumber:28,selectionStartColumn:1,selectionStartLineNumber:28,startColumn:1,startLineNumber:28),source:'%23include+%3Ciostream%3E%0A%23include+%3Cmemory%3E%0A%0Aclass+A+%7B%0Apublic:%0A++++virtual+void+hello()+const+%7B+std::cout+%3C%3C+%22Hello+from+A%22+%3C%3C+std::endl%3B+%7D%0A%7D%3B%0A%0Aclass+B:+public+A+%7B%0Apublic:%0A++++void+hello()+const+override+%7B+std::cout+%3C%3C+%22Hello+from+B%22+%3C%3C+std::endl%3B+%7D%0A%7D%3B%0A%0Aclass+Base+%7B%0Apublic:%0A++++virtual+const+A*+bar()+%7B+return+%26a%3B+%7D%0Aprivate:%0A++++A+a%3B%0A%7D%3B%0A%0Aclass+Derived:+public+Base+%7B%0Apublic:%0A++++B*+bar()+override+%7B+return+%26b%3B+%7D%0Aprivate:%0A++++B+b%3B%0A%7D%3B%0A%0A%0Aint+main()+%7B%0A++++Derived+d%7B%7D%3B%0A++++d.bar()-%3Ehello()%3B%0A%0A++++Base+%26b+%3D+d%3B%0A++++b.bar()-%3Ehello()%3B%0A%0A++++return+0%3B%0A%7D'),l:'5',n:'0',o:'C%2B%2B+source+%231',t:'0')),k:46.768507638072855,l:'4',n:'0',o:'',s:0,t:'0'),(g:!((g:!((h:executor,i:(argsPanelShown:'1',compilationPanelShown:'0',compiler:g142,compilerName:'',compilerOutShown:'0',execArgs:'',execStdin:'',fontScale:14,fontUsePx:'0',j:1,lang:c%2B%2B,libs:!(),options:'-std%3Dc%2B%2B17',overrides:!(),runtimeTools:!(),source:1,stdinPanelShown:'1',wrap:'1'),l:'5',n:'0',o:'Executor+x86-64+gcc+14.2+(C%2B%2B,+Editor+%231)',t:'0')),k:100,l:'4',m:45.26795895096921,n:'0',o:'',s:0,t:'0'),(g:!((h:executor,i:(argsPanelShown:'1',compilationPanelShown:'0',compiler:clang1910,compilerName:'',compilerOutShown:'0',execArgs:'',execStdin:'',fontScale:14,fontUsePx:'0',j:2,lang:c%2B%2B,libs:!(),options:'-std%3Dc%2B%2B17',overrides:!(),runtimeTools:!(),source:1,stdinPanelShown:'1',wrap:'1'),l:'5',n:'0',o:'Executor+x86-64+clang+19.1.0+(C%2B%2B,+Editor+%231)',t:'0')),header:(),k:100,l:'4',m:54.73204104903079,n:'0',o:'',s:0,t:'0')),k:53.231492361927145,l:'3',n:'0',o:'',t:'0')),l:'2',n:'0',o:'',t:'0')),version:4">continue to work</a>
(because <code>B*</code> is less cv-qualified than <code>const A*</code>).</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>class</span> <span class=nc>Base</span> <span class=p>{</span>
</span></span><span class=line><span class=cl><span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=k>virtual</span> <span class=k>const</span> <span class=n>A</span><span class=o>*</span> <span class=n>bar</span><span class=p>()</span> <span class=p>{</span> <span class=k>return</span> <span class=o>&amp;</span><span class=n>a</span><span class=p>;</span> <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=k>private</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=n>A</span> <span class=n>a</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>class</span> <span class=nc>Derived</span><span class=o>:</span> <span class=k>public</span> <span class=n>Base</span> <span class=p>{</span>
</span></span><span class=line><span class=cl><span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=c1>// return type is different
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>B</span><span class=o>*</span> <span class=n>bar</span><span class=p>()</span> <span class=k>override</span> <span class=p>{</span> <span class=k>return</span> <span class=o>&amp;</span><span class=n>b</span><span class=p>;</span> <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=k>private</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=n>B</span> <span class=n>b</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span></code></pre></div><h2 id=notes>Notes<a hidden class=anchor aria-hidden=true href=#notes>#</a></h2><p>I haven&rsquo;t seen this trick in production code since then, so its usefulness is questionable.</p><p>Potentially, it can be used to get the implementation of the interface from the interface itself
in places where the implementation class is accessible.</p></div><footer class=post-footer><ul class=post-tags><li><a href=https://andreynautilus.github.io/tags/c++/>C++</a></li></ul><nav class=paginav><a class=prev href=https://andreynautilus.github.io/posts/2025-06-14-areas-on-hex-grid/><span class=title>« Prev</span><br><span>Areas on hexagon grid</span>
</a><a class=next href=https://andreynautilus.github.io/posts/2025-04-24-mysterious-signed-operand/><span class=title>Next »</span><br><span>Mysterious signed operand in a C++ expression</span></a></nav></footer></article></main><footer class=footer><span>&copy; 2025 <a href=https://andreynautilus.github.io/>Andrey Nautilus blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>
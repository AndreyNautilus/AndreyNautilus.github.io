<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Canvas Drawing</title>
</head>
<body>
    <canvas id="canvas" width="500" height="500" style="border:1px solid black;"></canvas>

    <script>
        const canvas = document.getElementById("canvas");
        const ctx = canvas.getContext("2d");

        const canvas_width = 500;
        const canvas_height = 500;

        const cell_radius = 8;
        const cell_diameter = 2 * cell_radius;

        const colors = [
            //"#c0392b",
            "#e74c3c",
            //"#9b59b6",
            "#8e44ad",
            "#2980b9",
            //"#3498db",
            "#1abc9c",
            //"#16a085",
            "#27ae60",
            //"#2ecc71",
            //"#f1c40f",
            "#f39c12",
            //"#e67e22",
            "#d35400",
        ]

        class Point {
            constructor(row, col) {
                this.row = row;
                this.col = col;
            }

            equals(other) {
                return this.row == other.row && this.col == other.col;
            }
        }

        // class HexGrid {
        //     constructor(rows_count, cols_count) {
        //         // this.cols_count = Math.floor((canvas_width - cell_radius) / cell_diameter);
        //         // this.rows_count = Math.floor(canvas_width / cell_diameter);
        //         this.cells = [];

        //         for (let row_idx = 0; row_idx < this.rows_count; ++row_idx) {
        //             this.cells[row_idx] = [];
        //             for (let col_idx = 0; col_idx < this.cols_count; ++col_idx) {
        //                 this.cells[row_idx][col_idx] = undefined;
        //             }
        //         }
        //     }
        // };

        // construct grid
        let cols_count = Math.floor((canvas_width - cell_radius) / cell_diameter);
        let rows_count = Math.floor(canvas_width / cell_diameter);
        console.log(`Size: ${cols_count} cols, ${rows_count} rows`)
        let grid = [];

        for (let row_idx = 0; row_idx < rows_count; ++row_idx) {
            grid[row_idx] = [];
            for (let col_idx = 0; col_idx < cols_count; ++col_idx) {
                grid[row_idx][col_idx] = undefined;
            }
        }
        console.log("Filling...");

        // fill in the grid
        const initialPoints = generateInitialPoints(colors.length);
        let areas = [];  // list of "list of points"
        for (let i = 0; i < initialPoints.length; ++i) {
            const p = initialPoints[i];
            areas.push([[p, i]]);
            grid[p.row][p.col] = i;
        }

        function randomInt(max) {
            return Math.floor(max * Math.random());
        }

        function randomIntPoint(rows_max, cols_max) {
            return new Point(randomInt(rows_max), randomInt(cols_max));
        }

        function generateInitialPoints(amount) {
            let result = [];
            for (let i = 0; i < amount; ++i) {
                let point = randomIntPoint(rows_count, cols_count);
                while (result.find((p) => point.equals(p)) != undefined) {
                    // re-generate in case of duplicates
                    point = randomIntPoint(rows_count, cols_count);
                }
                result.push(point);
            }
            return result;
        }

        let expandable_points_count = areas.reduce((acc, points) => acc + points.length, 0)
        let area_idx = 0;
        let iter = 0;
        while (expandable_points_count > 0) {
            ++iter;

            let log = `${iter} [${expandable_points_count}]: `
            areas.forEach((area) => log += `${area.length} `);
            console.log(log);

            // choose area
            //const area_idx = Math.floor(areas.length * Math.random());
            area_idx = (area_idx + 1) % areas.length;
            let area = areas[area_idx];
            console.log(`Area number ${area_idx}`);

            // choose area point to expand
            let point_idx = Math.floor(area.length * Math.random());
            const [point, color_idx] = area[point_idx];
            let candidates = getNeighbors(point);
            candidates = candidates.filter((p) => grid[p[0]][p[1]] == undefined);
            const [cand_row, cand_col] = candidates[Math.floor(candidates.length * Math.random())];
            area.push([new Point(cand_row, cand_col), color_idx]);
            grid[cand_row][cand_col] = color_idx;

            // clean up points and areas
            //console.log(`Area size: ${area.length}`);
            for (let i = 0; i < areas.length; ++i) {
                areas[i] = areas[i].filter(([point, color_idx]) => {
                    let candidates = getNeighbors(point);
                    candidates = candidates.filter((p) => grid[p[0]][p[1]] == undefined);
                    return candidates.length > 0;
                });
                //console.log(`Area size(after cleanup): ${areas[i].length}`);
            }

            areas = areas.filter((area) => area.length > 0);
            expandable_points_count = areas.reduce((acc, points) => acc + points.length, 0);
        }

        function getNeighbors(point) {
            let candidates = [];
            if (point.row % 2 == 0) {
                candidates = [
                    [point.row, point.col - 1],
                    [point.row - 1, point.col - 1],
                    [point.row - 1, point.col],
                    [point.row, point.col + 1],
                    [point.row + 1, point.col],
                    [point.row + 1, point.col - 1],
                ];
            } else {
                candidates = [
                    [point.row, point.col - 1],
                    [point.row - 1, point.col],
                    [point.row - 1, point.col + 1],
                    [point.row, point.col + 1],
                    [point.row + 1, point.col + 1],
                    [point.row + 1, point.col],
                ];
            }
            return candidates.filter(([p_row, p_col]) => {
                return (0 <= p_row) && (p_row < rows_count) && (0 <= p_col) && (p_col < cols_count);
            });//.map(([p_row, p_col]) => new Point(p_row, p_col));
        }

        // draw grid
        for (let row_idx = 0; row_idx < rows_count; ++row_idx) {
            for (let col_idx = 0; col_idx < cols_count; ++col_idx) {
                const x = cell_radius + cell_radius * (row_idx % 2) + col_idx * cell_diameter;
                const y = cell_radius + row_idx * cell_diameter;

                ctx.beginPath();
                ctx.arc(x, y, cell_radius, 0, Math.PI * 2);

                const color_idx = grid[row_idx][col_idx];
                if (color_idx != undefined) {
                    ctx.fillStyle = colors[color_idx];
                } else {
                    ctx.fillStyle = "black";
                }

                ctx.fill();
            }
        }
    </script>
</body>
</html>
